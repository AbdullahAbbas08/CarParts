//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class SwaggerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:5200";
    }

    apiCategoriesGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Categories/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfCategoryDto>;
        }));
    }

    protected processApiCategoriesGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesGetDetailsGet(id: number | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/Categories/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto>;
        }));
    }

    protected processApiCategoriesGetDetailsGet(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesInsertPost(entity: CategoryDto): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/Categories/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto>;
        }));
    }

    protected processApiCategoriesInsertPost(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesUpdatePost(entity: CategoryDto): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/Categories/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto>;
        }));
    }

    protected processApiCategoriesUpdatePost(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesDeletePost(id: number | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/Categories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto>;
        }));
    }

    protected processApiCategoriesDeletePost(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfMerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfMerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfMerchantDTO>;
        }));
    }

    protected processApiMerchantGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfMerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfMerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantGetDetailsGet(id: number | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantGetDetailsGet(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantInsertPost(entity: MerchantDTO): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantInsertPost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantUpdatePost(entity: MerchantDTO): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantUpdatePost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantDeletePost(id: number | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantDeletePost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfPartDTO> {
        let url_ = this.baseUrl + "/api/Parts/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfPartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfPartDTO>;
        }));
    }

    protected processApiPartsGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfPartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfPartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsGetDetailsGet(id: number | undefined): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsGetDetailsGet(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsInsertPost(entity: PartDTO): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsInsertPost(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsUpdatePost(entity: PartDTO): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsUpdatePost(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsDeletePost(id: number | undefined): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsDeletePost(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountLoginPost(loginViewModel: LoginViewModel): Observable<AuthDto> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountLoginPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountLoginPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthDto>;
        }));
    }

    protected processApiAccountLoginPost(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountRegisterNewUserPost(registerViewModel: RegisterViewModel): Observable<AuthDto> {
        let url_ = this.baseUrl + "/api/Account/RegisterNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountRegisterNewUserPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountRegisterNewUserPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthDto>;
        }));
    }

    protected processApiAccountRegisterNewUserPost(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountRegisterNewVisitorPost(visitorViewModel: VisitorViewModel): Observable<AuthDto> {
        let url_ = this.baseUrl + "/api/Account/RegisterNewVisitor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(visitorViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountRegisterNewVisitorPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountRegisterNewVisitorPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthDto>;
        }));
    }

    protected processApiAccountRegisterNewVisitorPost(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfUserDTO> {
        let url_ = this.baseUrl + "/api/Account/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfUserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfUserDTO>;
        }));
    }

    protected processApiAccountGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfUserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfUserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountGetDetailsGet(id: number | undefined): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountGetDetailsGet(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountInsertPost(entity: UserDTO): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountInsertPost(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountUpdatePost(entity: UserDTO): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountUpdatePost(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountDeletePost(id: number | undefined): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountDeletePost(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfCarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfCarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfCarsModelDto>;
        }));
    }

    protected processApiCarsModelGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfCarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfCarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelGetDetailsGet(id: number | undefined): Observable<CarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarsModelDto>;
        }));
    }

    protected processApiCarsModelGetDetailsGet(response: HttpResponseBase): Observable<CarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelInsertPost(entity: CarsModelDto): Observable<CarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarsModelDto>;
        }));
    }

    protected processApiCarsModelInsertPost(response: HttpResponseBase): Observable<CarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelUpdatePost(entity: CarsModelDto): Observable<CarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarsModelDto>;
        }));
    }

    protected processApiCarsModelUpdatePost(response: HttpResponseBase): Observable<CarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelDeletePost(id: number | undefined): Observable<CarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarsModelDto>;
        }));
    }

    protected processApiCarsModelDeletePost(response: HttpResponseBase): Observable<CarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfCityDTO> {
        let url_ = this.baseUrl + "/api/City/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfCityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfCityDTO>;
        }));
    }

    protected processApiCityGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfCityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfCityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityGetDetailsGet(id: number | undefined): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityGetDetailsGet(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityInsertPost(entity: CityDTO): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityInsertPost(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityUpdatePost(entity: CityDTO): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityUpdatePost(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityDeletePost(id: number | undefined): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityDeletePost(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetLookupGet(lookupName: string | undefined, searchTerm: string | null | undefined): Observable<LookupDTO[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetLookup?";
        if (lookupName === null)
            throw new Error("The parameter 'lookupName' cannot be null.");
        else if (lookupName !== undefined)
            url_ += "lookupName=" + encodeURIComponent("" + lookupName) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetLookupGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetLookupGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupDTO[]>;
        }));
    }

    protected processApiLookupGetLookupGet(response: HttpResponseBase): Observable<LookupDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiSellerCategoryGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfSellerCategoryDTO> {
        let url_ = this.baseUrl + "/api/SellerCategory/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSellerCategoryGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSellerCategoryGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfSellerCategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfSellerCategoryDTO>;
        }));
    }

    protected processApiSellerCategoryGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfSellerCategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfSellerCategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiSellerCategoryGetDetailsGet(id: number | undefined): Observable<SellerCategoryDTO> {
        let url_ = this.baseUrl + "/api/SellerCategory/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSellerCategoryGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSellerCategoryGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SellerCategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SellerCategoryDTO>;
        }));
    }

    protected processApiSellerCategoryGetDetailsGet(response: HttpResponseBase): Observable<SellerCategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerCategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiSellerCategoryInsertPost(entity: SellerCategoryDTO): Observable<SellerCategoryDTO> {
        let url_ = this.baseUrl + "/api/SellerCategory/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSellerCategoryInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSellerCategoryInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SellerCategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SellerCategoryDTO>;
        }));
    }

    protected processApiSellerCategoryInsertPost(response: HttpResponseBase): Observable<SellerCategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerCategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiSellerCategoryUpdatePost(entity: SellerCategoryDTO): Observable<SellerCategoryDTO> {
        let url_ = this.baseUrl + "/api/SellerCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSellerCategoryUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSellerCategoryUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SellerCategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SellerCategoryDTO>;
        }));
    }

    protected processApiSellerCategoryUpdatePost(response: HttpResponseBase): Observable<SellerCategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerCategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiSellerCategoryDeletePost(id: number | undefined): Observable<SellerCategoryDTO> {
        let url_ = this.baseUrl + "/api/SellerCategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSellerCategoryDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSellerCategoryDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SellerCategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SellerCategoryDTO>;
        }));
    }

    protected processApiSellerCategoryDeletePost(response: HttpResponseBase): Observable<SellerCategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerCategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class DataSourceResultOfCategoryDto implements IDataSourceResultOfCategoryDto {
    data!: CategoryDto[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDto.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfCategoryDto {
    data: CategoryDto[];
    count: number;
    additionalValue: number;
}

export class CategoryDto implements ICategoryDto {
    id!: number;
    name!: string;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICategoryDto {
    id: number;
    name: string;
}

export class DataSourceResultOfMerchantDTO implements IDataSourceResultOfMerchantDTO {
    data!: MerchantDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfMerchantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MerchantDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfMerchantDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfMerchantDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfMerchantDTO {
    data: MerchantDTO[];
    count: number;
    additionalValue: number;
}

export class MerchantDTO implements IMerchantDTO {
    id!: number;
    shopName!: string;
    logo!: string;
    slug!: string;
    description!: string;
    shortDescription!: string;
    address!: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    rating!: number;
    ratingCount!: number;
    cityId?: number | undefined;
    isFavoriteMerchant!: boolean;
    commercialRegistrationNumber!: string;
    commercialRegistrationImageForm!: any;
    commercialRegistrationImage!: string;
    nationalIdNumber!: string;
    nationalIdImageForm!: any;
    nationalIdImage!: string;
    members!: UserDTO[];
    city!: CityDTO;
    governorate!: GovernorateDTO;
    parts!: PartDTO[];
    sellerCategories!: SellerCategoryDTO[];
    deletedBy?: number | undefined;
    deletedOn?: Date | undefined;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;

    constructor(data?: IMerchantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.members = [];
            this.city = new CityDTO();
            this.governorate = new GovernorateDTO();
            this.parts = [];
            this.sellerCategories = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shopName = _data["shopName"];
            this.logo = _data["logo"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.address = _data["address"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.rating = _data["rating"];
            this.ratingCount = _data["ratingCount"];
            this.cityId = _data["cityId"];
            this.isFavoriteMerchant = _data["isFavoriteMerchant"];
            this.commercialRegistrationNumber = _data["commercialRegistrationNumber"];
            this.commercialRegistrationImageForm = _data["commercialRegistrationImageForm"];
            this.commercialRegistrationImage = _data["commercialRegistrationImage"];
            this.nationalIdNumber = _data["nationalIdNumber"];
            this.nationalIdImageForm = _data["nationalIdImageForm"];
            this.nationalIdImage = _data["nationalIdImage"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(UserDTO.fromJS(item));
            }
            this.city = _data["city"] ? CityDTO.fromJS(_data["city"]) : new CityDTO();
            this.governorate = _data["governorate"] ? GovernorateDTO.fromJS(_data["governorate"]) : new GovernorateDTO();
            if (Array.isArray(_data["parts"])) {
                this.parts = [] as any;
                for (let item of _data["parts"])
                    this.parts!.push(PartDTO.fromJS(item));
            }
            if (Array.isArray(_data["sellerCategories"])) {
                this.sellerCategories = [] as any;
                for (let item of _data["sellerCategories"])
                    this.sellerCategories!.push(SellerCategoryDTO.fromJS(item));
            }
            this.deletedBy = _data["deletedBy"];
            this.deletedOn = _data["deletedOn"] ? new Date(_data["deletedOn"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            this.createdByUserId = _data["createdByUserId"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MerchantDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shopName"] = this.shopName;
        data["logo"] = this.logo;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["address"] = this.address;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["rating"] = this.rating;
        data["ratingCount"] = this.ratingCount;
        data["cityId"] = this.cityId;
        data["isFavoriteMerchant"] = this.isFavoriteMerchant;
        data["commercialRegistrationNumber"] = this.commercialRegistrationNumber;
        data["commercialRegistrationImageForm"] = this.commercialRegistrationImageForm;
        data["commercialRegistrationImage"] = this.commercialRegistrationImage;
        data["nationalIdNumber"] = this.nationalIdNumber;
        data["nationalIdImageForm"] = this.nationalIdImageForm;
        data["nationalIdImage"] = this.nationalIdImage;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item.toJSON());
        }
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["governorate"] = this.governorate ? this.governorate.toJSON() : <any>undefined;
        if (Array.isArray(this.parts)) {
            data["parts"] = [];
            for (let item of this.parts)
                data["parts"].push(item.toJSON());
        }
        if (Array.isArray(this.sellerCategories)) {
            data["sellerCategories"] = [];
            for (let item of this.sellerCategories)
                data["sellerCategories"].push(item.toJSON());
        }
        data["deletedBy"] = this.deletedBy;
        data["deletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["createdByUserId"] = this.createdByUserId;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMerchantDTO {
    id: number;
    shopName: string;
    logo: string;
    slug: string;
    description: string;
    shortDescription: string;
    address: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    rating: number;
    ratingCount: number;
    cityId?: number | undefined;
    isFavoriteMerchant: boolean;
    commercialRegistrationNumber: string;
    commercialRegistrationImageForm: any;
    commercialRegistrationImage: string;
    nationalIdNumber: string;
    nationalIdImageForm: any;
    nationalIdImage: string;
    members: UserDTO[];
    city: CityDTO;
    governorate: GovernorateDTO;
    parts: PartDTO[];
    sellerCategories: SellerCategoryDTO[];
    deletedBy?: number | undefined;
    deletedOn?: Date | undefined;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;
}

export class UserDTO implements IUserDTO {
    id!: number;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    userType!: UserTypeEnum;
    userTypeName?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.userType = _data["userType"];
            this.userTypeName = _data["userTypeName"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["userType"] = this.userType;
        data["userTypeName"] = this.userTypeName;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        return data;
    }
}

export interface IUserDTO {
    id: number;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    userType: UserTypeEnum;
    userTypeName?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
}

export enum UserTypeEnum {
    Admin = 1,
    Client = 2,
    Seller = 3,
    ShippingCompany = 4,
}

export class CityDTO implements ICityDTO {
    id!: number;
    nameAr!: string;
    nameEn!: string;

    constructor(data?: ICityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
        }
    }

    static fromJS(data: any): CityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        return data;
    }
}

export interface ICityDTO {
    id: number;
    nameAr: string;
    nameEn: string;
}

export class GovernorateDTO implements IGovernorateDTO {
    id!: number;
    name!: string;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;
    createdByUser!: UserDTO;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    updatedByUser!: UserDTO;
    cities!: CityDTO[];

    constructor(data?: IGovernorateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdByUser = new UserDTO();
            this.updatedByUser = new UserDTO();
            this.cities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.createdByUserId = _data["createdByUserId"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.createdByUser = _data["createdByUser"] ? UserDTO.fromJS(_data["createdByUser"]) : new UserDTO();
            this.updatedBy = _data["updatedBy"];
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            this.updatedByUser = _data["updatedByUser"] ? UserDTO.fromJS(_data["updatedByUser"]) : new UserDTO();
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities!.push(CityDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GovernorateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GovernorateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["createdByUserId"] = this.createdByUserId;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : <any>undefined;
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGovernorateDTO {
    id: number;
    name: string;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;
    createdByUser: UserDTO;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    updatedByUser: UserDTO;
    cities: CityDTO[];
}

export class PartDTO implements IPartDTO {
    id!: number;
    name!: string;
    description!: string;
    price!: number;
    condition!: PartConditionEnum;
    conditionName!: string;
    imageUrl!: string;
    sellerId!: number;
    sellerName!: string;
    categoryId!: number;
    categoryName!: string;
    carModelId?: number | undefined;
    carModelName?: string | undefined;

    constructor(data?: IPartDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.condition = _data["condition"];
            this.conditionName = _data["conditionName"];
            this.imageUrl = _data["imageUrl"];
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.carModelId = _data["carModelId"];
            this.carModelName = _data["carModelName"];
        }
    }

    static fromJS(data: any): PartDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PartDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["condition"] = this.condition;
        data["conditionName"] = this.conditionName;
        data["imageUrl"] = this.imageUrl;
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["carModelId"] = this.carModelId;
        data["carModelName"] = this.carModelName;
        return data;
    }
}

export interface IPartDTO {
    id: number;
    name: string;
    description: string;
    price: number;
    condition: PartConditionEnum;
    conditionName: string;
    imageUrl: string;
    sellerId: number;
    sellerName: string;
    categoryId: number;
    categoryName: string;
    carModelId?: number | undefined;
    carModelName?: string | undefined;
}

export enum PartConditionEnum {
    New = 1,
    Used = 2,
    Refurbished = 3,
}

export class SellerCategoryDTO implements ISellerCategoryDTO {
    id!: number;
    name!: string;

    constructor(data?: ISellerCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SellerCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SellerCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISellerCategoryDTO {
    id: number;
    name: string;
}

export class DataSourceResultOfPartDTO implements IDataSourceResultOfPartDTO {
    data!: PartDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfPartDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PartDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfPartDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfPartDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfPartDTO {
    data: PartDTO[];
    count: number;
    additionalValue: number;
}

export class AuthDto implements IAuthDto {
    userId!: number;
    userName!: string;
    fullName!: string;
    phoneNumber?: string | undefined;
    photo?: string | undefined;
    token!: string;
    message!: string;
    statusCode?: number | undefined;
    isAuthenticated!: boolean;
    isAdmin!: boolean;
    userType!: UserTypeEnum;

    constructor(data?: IAuthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.photo = _data["photo"];
            this.token = _data["token"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.isAdmin = _data["isAdmin"];
            this.userType = _data["userType"];
        }
    }

    static fromJS(data: any): AuthDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["photo"] = this.photo;
        data["token"] = this.token;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["isAuthenticated"] = this.isAuthenticated;
        data["isAdmin"] = this.isAdmin;
        data["userType"] = this.userType;
        return data;
    }
}

export interface IAuthDto {
    userId: number;
    userName: string;
    fullName: string;
    phoneNumber?: string | undefined;
    photo?: string | undefined;
    token: string;
    message: string;
    statusCode?: number | undefined;
    isAuthenticated: boolean;
    isAdmin: boolean;
    userType: UserTypeEnum;
}

export class LoginViewModel implements ILoginViewModel {
    email!: string;
    password!: string;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginViewModel {
    email: string;
    password: string;
}

export class RegisterViewModel implements IRegisterViewModel {
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    photo?: string | undefined;
    address?: string | undefined;
    userType!: UserTypeEnum;

    constructor(data?: IRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.photo = _data["photo"];
            this.address = _data["address"];
            this.userType = _data["userType"];
        }
    }

    static fromJS(data: any): RegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["photo"] = this.photo;
        data["address"] = this.address;
        data["userType"] = this.userType;
        return data;
    }
}

export interface IRegisterViewModel {
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    photo?: string | undefined;
    address?: string | undefined;
    userType: UserTypeEnum;
}

export class VisitorViewModel implements IVisitorViewModel {
    userName!: string;
    fullName!: string;
    email!: string;
    phoneNumber!: string;
    address!: string;

    constructor(data?: IVisitorViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): VisitorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new VisitorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        return data;
    }
}

export interface IVisitorViewModel {
    userName: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    address: string;
}

export class DataSourceResultOfUserDTO implements IDataSourceResultOfUserDTO {
    data!: UserDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfUserDTO {
    data: UserDTO[];
    count: number;
    additionalValue: number;
}

export class DataSourceResultOfCarsModelDto implements IDataSourceResultOfCarsModelDto {
    data!: CarsModelDto[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfCarsModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CarsModelDto.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCarsModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCarsModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfCarsModelDto {
    data: CarsModelDto[];
    count: number;
    additionalValue: number;
}

export class CarsModelDto implements ICarsModelDto {
    id!: number;
    name!: string;

    constructor(data?: ICarsModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CarsModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarsModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICarsModelDto {
    id: number;
    name: string;
}

export class DataSourceResultOfCityDTO implements IDataSourceResultOfCityDTO {
    data!: CityDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfCityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CityDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfCityDTO {
    data: CityDTO[];
    count: number;
    additionalValue: number;
}

export class LookupDTO implements ILookupDTO {
    id!: any;
    text!: string;

    constructor(data?: ILookupDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): LookupDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data;
    }
}

export interface ILookupDTO {
    id: any;
    text: string;
}

export class DataSourceResultOfSellerCategoryDTO implements IDataSourceResultOfSellerCategoryDTO {
    data!: SellerCategoryDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfSellerCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SellerCategoryDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfSellerCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfSellerCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfSellerCategoryDTO {
    data: SellerCategoryDTO[];
    count: number;
    additionalValue: number;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}