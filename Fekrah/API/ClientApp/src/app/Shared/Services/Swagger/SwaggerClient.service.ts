//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class SwaggerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:5200";
    }

    apiCategoriesGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfCategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfCategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfCategoryDTO>;
        }));
    }

    protected processApiCategoriesGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfCategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfCategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesGetDetailsGet(id: number | undefined): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO>;
        }));
    }

    protected processApiCategoriesGetDetailsGet(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesInsertPost(entity: CategoryDTO): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO>;
        }));
    }

    protected processApiCategoriesInsertPost(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesUpdatePost(entity: CategoryDTO): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO>;
        }));
    }

    protected processApiCategoriesUpdatePost(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesDeletePost(id: number | undefined): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO>;
        }));
    }

    protected processApiCategoriesDeletePost(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantGetDataByIdGet(id: number): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/GetDataById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantGetDataByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantGetDataByIdGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantGetDataByIdGet(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantInsertMerchantPost(id: number | undefined, code: string | null | undefined, status: MerchantStatus | null | undefined, shopName: string | undefined, slug: string | undefined, description: string | undefined, shortDescription: string | undefined, locationOnMap: string | undefined, address: string | undefined, latitude: number | null | undefined, longitude: number | null | undefined, rating: number | undefined, ratingCount: number | undefined, mobileNo: string | undefined, whatsAppMobileNo: string | undefined, email: string | null | undefined, governorateId: number | null | undefined, cityId: number | null | undefined, isFavoriteMerchant: boolean | undefined, commercialRegistrationNumber: string | undefined, nationalIdNumber: string | undefined, businessHours: string | undefined, logo: string | null | undefined, commercialRegistrationImage: string | null | undefined, nationalIdImage: string | null | undefined, nationalIdImageForm: FileParameter | null | undefined, logoForm: FileParameter | null | undefined, commercialRegistrationImageForm: FileParameter | null | undefined, membersJson: string | null | undefined, members: MemberDTO[] | null | undefined, city_Id: number | undefined, city_NameAr: string | undefined, city_NameEn: string | undefined, governorate_Id: number | undefined, governorate_Name: string | undefined, governorate_CreatedByUserId: number | null | undefined, governorate_CreatedOn: Date | null | undefined, governorate_CreatedByUser_Id: number | undefined, governorate_CreatedByUser_NationalId: string | null | undefined, governorate_CreatedByUser_UserName: string | null | undefined, governorate_CreatedByUser_FullName: string | null | undefined, governorate_CreatedByUser_Email: string | null | undefined, governorate_CreatedByUser_Password: string | null | undefined, governorate_CreatedByUser_Photo: string | null | undefined, governorate_CreatedByUser_UserType: UserTypeEnum | null | undefined, governorate_CreatedByUser_PhoneNumber: string | null | undefined, governorate_CreatedByUser_Address: string | null | undefined, governorate_CreatedByUser_IsActive: boolean | null | undefined, governorate_UpdatedBy: number | null | undefined, governorate_UpdatedOn: Date | null | undefined, governorate_UpdatedByUser_Id: number | undefined, governorate_UpdatedByUser_NationalId: string | null | undefined, governorate_UpdatedByUser_UserName: string | null | undefined, governorate_UpdatedByUser_FullName: string | null | undefined, governorate_UpdatedByUser_Email: string | null | undefined, governorate_UpdatedByUser_Password: string | null | undefined, governorate_UpdatedByUser_Photo: string | null | undefined, governorate_UpdatedByUser_UserType: UserTypeEnum | null | undefined, governorate_UpdatedByUser_PhoneNumber: string | null | undefined, governorate_UpdatedByUser_Address: string | null | undefined, governorate_UpdatedByUser_IsActive: boolean | null | undefined, governorate_Cities: CityDTO[] | undefined, createdOn: Date | null | undefined, categoriesJson: string | null | undefined, categoriesDTO: CategoryDTO[] | null | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/InsertMerchant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (code !== null && code !== undefined)
            content_.append("Code", code.toString());
        if (status !== null && status !== undefined)
            content_.append("Status", status.toString());
        if (shopName === null || shopName === undefined)
            throw new Error("The parameter 'shopName' cannot be null.");
        else
            content_.append("ShopName", shopName.toString());
        if (slug === null || slug === undefined)
            throw new Error("The parameter 'slug' cannot be null.");
        else
            content_.append("Slug", slug.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (shortDescription === null || shortDescription === undefined)
            throw new Error("The parameter 'shortDescription' cannot be null.");
        else
            content_.append("ShortDescription", shortDescription.toString());
        if (locationOnMap === null || locationOnMap === undefined)
            throw new Error("The parameter 'locationOnMap' cannot be null.");
        else
            content_.append("LocationOnMap", locationOnMap.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (latitude !== null && latitude !== undefined)
            content_.append("Latitude", latitude.toString());
        if (longitude !== null && longitude !== undefined)
            content_.append("Longitude", longitude.toString());
        if (rating === null || rating === undefined)
            throw new Error("The parameter 'rating' cannot be null.");
        else
            content_.append("Rating", rating.toString());
        if (ratingCount === null || ratingCount === undefined)
            throw new Error("The parameter 'ratingCount' cannot be null.");
        else
            content_.append("RatingCount", ratingCount.toString());
        if (mobileNo === null || mobileNo === undefined)
            throw new Error("The parameter 'mobileNo' cannot be null.");
        else
            content_.append("MobileNo", mobileNo.toString());
        if (whatsAppMobileNo === null || whatsAppMobileNo === undefined)
            throw new Error("The parameter 'whatsAppMobileNo' cannot be null.");
        else
            content_.append("WhatsAppMobileNo", whatsAppMobileNo.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (governorateId !== null && governorateId !== undefined)
            content_.append("GovernorateId", governorateId.toString());
        if (cityId !== null && cityId !== undefined)
            content_.append("CityId", cityId.toString());
        if (isFavoriteMerchant === null || isFavoriteMerchant === undefined)
            throw new Error("The parameter 'isFavoriteMerchant' cannot be null.");
        else
            content_.append("IsFavoriteMerchant", isFavoriteMerchant.toString());
        if (commercialRegistrationNumber === null || commercialRegistrationNumber === undefined)
            throw new Error("The parameter 'commercialRegistrationNumber' cannot be null.");
        else
            content_.append("CommercialRegistrationNumber", commercialRegistrationNumber.toString());
        if (nationalIdNumber === null || nationalIdNumber === undefined)
            throw new Error("The parameter 'nationalIdNumber' cannot be null.");
        else
            content_.append("NationalIdNumber", nationalIdNumber.toString());
        if (businessHours === null || businessHours === undefined)
            throw new Error("The parameter 'businessHours' cannot be null.");
        else
            content_.append("BusinessHours", businessHours.toString());
        if (logo !== null && logo !== undefined)
            content_.append("Logo", logo.toString());
        if (commercialRegistrationImage !== null && commercialRegistrationImage !== undefined)
            content_.append("CommercialRegistrationImage", commercialRegistrationImage.toString());
        if (nationalIdImage !== null && nationalIdImage !== undefined)
            content_.append("NationalIdImage", nationalIdImage.toString());
        if (nationalIdImageForm !== null && nationalIdImageForm !== undefined)
            content_.append("NationalIdImageForm", nationalIdImageForm.data, nationalIdImageForm.fileName ? nationalIdImageForm.fileName : "NationalIdImageForm");
        if (logoForm !== null && logoForm !== undefined)
            content_.append("LogoForm", logoForm.data, logoForm.fileName ? logoForm.fileName : "LogoForm");
        if (commercialRegistrationImageForm !== null && commercialRegistrationImageForm !== undefined)
            content_.append("CommercialRegistrationImageForm", commercialRegistrationImageForm.data, commercialRegistrationImageForm.fileName ? commercialRegistrationImageForm.fileName : "CommercialRegistrationImageForm");
        if (membersJson !== null && membersJson !== undefined)
            content_.append("MembersJson", membersJson.toString());
        if (members !== null && members !== undefined)
            members.forEach(item_ => content_.append("Members", item_.toString()));
        if (city_Id === null || city_Id === undefined)
            throw new Error("The parameter 'city_Id' cannot be null.");
        else
            content_.append("City.Id", city_Id.toString());
        if (city_NameAr === null || city_NameAr === undefined)
            throw new Error("The parameter 'city_NameAr' cannot be null.");
        else
            content_.append("City.NameAr", city_NameAr.toString());
        if (city_NameEn === null || city_NameEn === undefined)
            throw new Error("The parameter 'city_NameEn' cannot be null.");
        else
            content_.append("City.NameEn", city_NameEn.toString());
        if (governorate_Id === null || governorate_Id === undefined)
            throw new Error("The parameter 'governorate_Id' cannot be null.");
        else
            content_.append("Governorate.Id", governorate_Id.toString());
        if (governorate_Name === null || governorate_Name === undefined)
            throw new Error("The parameter 'governorate_Name' cannot be null.");
        else
            content_.append("Governorate.Name", governorate_Name.toString());
        if (governorate_CreatedByUserId !== null && governorate_CreatedByUserId !== undefined)
            content_.append("Governorate.CreatedByUserId", governorate_CreatedByUserId.toString());
        if (governorate_CreatedOn !== null && governorate_CreatedOn !== undefined)
            content_.append("Governorate.CreatedOn", governorate_CreatedOn.toJSON());
        if (governorate_CreatedByUser_Id === null || governorate_CreatedByUser_Id === undefined)
            throw new Error("The parameter 'governorate_CreatedByUser_Id' cannot be null.");
        else
            content_.append("Governorate.CreatedByUser.Id", governorate_CreatedByUser_Id.toString());
        if (governorate_CreatedByUser_NationalId !== null && governorate_CreatedByUser_NationalId !== undefined)
            content_.append("Governorate.CreatedByUser.NationalId", governorate_CreatedByUser_NationalId.toString());
        if (governorate_CreatedByUser_UserName !== null && governorate_CreatedByUser_UserName !== undefined)
            content_.append("Governorate.CreatedByUser.UserName", governorate_CreatedByUser_UserName.toString());
        if (governorate_CreatedByUser_FullName !== null && governorate_CreatedByUser_FullName !== undefined)
            content_.append("Governorate.CreatedByUser.FullName", governorate_CreatedByUser_FullName.toString());
        if (governorate_CreatedByUser_Email !== null && governorate_CreatedByUser_Email !== undefined)
            content_.append("Governorate.CreatedByUser.Email", governorate_CreatedByUser_Email.toString());
        if (governorate_CreatedByUser_Password !== null && governorate_CreatedByUser_Password !== undefined)
            content_.append("Governorate.CreatedByUser.Password", governorate_CreatedByUser_Password.toString());
        if (governorate_CreatedByUser_Photo !== null && governorate_CreatedByUser_Photo !== undefined)
            content_.append("Governorate.CreatedByUser.Photo", governorate_CreatedByUser_Photo.toString());
        if (governorate_CreatedByUser_UserType !== null && governorate_CreatedByUser_UserType !== undefined)
            content_.append("Governorate.CreatedByUser.UserType", governorate_CreatedByUser_UserType.toString());
        if (governorate_CreatedByUser_PhoneNumber !== null && governorate_CreatedByUser_PhoneNumber !== undefined)
            content_.append("Governorate.CreatedByUser.PhoneNumber", governorate_CreatedByUser_PhoneNumber.toString());
        if (governorate_CreatedByUser_Address !== null && governorate_CreatedByUser_Address !== undefined)
            content_.append("Governorate.CreatedByUser.Address", governorate_CreatedByUser_Address.toString());
        if (governorate_CreatedByUser_IsActive !== null && governorate_CreatedByUser_IsActive !== undefined)
            content_.append("Governorate.CreatedByUser.IsActive", governorate_CreatedByUser_IsActive.toString());
        if (governorate_UpdatedBy !== null && governorate_UpdatedBy !== undefined)
            content_.append("Governorate.UpdatedBy", governorate_UpdatedBy.toString());
        if (governorate_UpdatedOn !== null && governorate_UpdatedOn !== undefined)
            content_.append("Governorate.UpdatedOn", governorate_UpdatedOn.toJSON());
        if (governorate_UpdatedByUser_Id === null || governorate_UpdatedByUser_Id === undefined)
            throw new Error("The parameter 'governorate_UpdatedByUser_Id' cannot be null.");
        else
            content_.append("Governorate.UpdatedByUser.Id", governorate_UpdatedByUser_Id.toString());
        if (governorate_UpdatedByUser_NationalId !== null && governorate_UpdatedByUser_NationalId !== undefined)
            content_.append("Governorate.UpdatedByUser.NationalId", governorate_UpdatedByUser_NationalId.toString());
        if (governorate_UpdatedByUser_UserName !== null && governorate_UpdatedByUser_UserName !== undefined)
            content_.append("Governorate.UpdatedByUser.UserName", governorate_UpdatedByUser_UserName.toString());
        if (governorate_UpdatedByUser_FullName !== null && governorate_UpdatedByUser_FullName !== undefined)
            content_.append("Governorate.UpdatedByUser.FullName", governorate_UpdatedByUser_FullName.toString());
        if (governorate_UpdatedByUser_Email !== null && governorate_UpdatedByUser_Email !== undefined)
            content_.append("Governorate.UpdatedByUser.Email", governorate_UpdatedByUser_Email.toString());
        if (governorate_UpdatedByUser_Password !== null && governorate_UpdatedByUser_Password !== undefined)
            content_.append("Governorate.UpdatedByUser.Password", governorate_UpdatedByUser_Password.toString());
        if (governorate_UpdatedByUser_Photo !== null && governorate_UpdatedByUser_Photo !== undefined)
            content_.append("Governorate.UpdatedByUser.Photo", governorate_UpdatedByUser_Photo.toString());
        if (governorate_UpdatedByUser_UserType !== null && governorate_UpdatedByUser_UserType !== undefined)
            content_.append("Governorate.UpdatedByUser.UserType", governorate_UpdatedByUser_UserType.toString());
        if (governorate_UpdatedByUser_PhoneNumber !== null && governorate_UpdatedByUser_PhoneNumber !== undefined)
            content_.append("Governorate.UpdatedByUser.PhoneNumber", governorate_UpdatedByUser_PhoneNumber.toString());
        if (governorate_UpdatedByUser_Address !== null && governorate_UpdatedByUser_Address !== undefined)
            content_.append("Governorate.UpdatedByUser.Address", governorate_UpdatedByUser_Address.toString());
        if (governorate_UpdatedByUser_IsActive !== null && governorate_UpdatedByUser_IsActive !== undefined)
            content_.append("Governorate.UpdatedByUser.IsActive", governorate_UpdatedByUser_IsActive.toString());
        if (governorate_Cities === null || governorate_Cities === undefined)
            throw new Error("The parameter 'governorate_Cities' cannot be null.");
        else
            governorate_Cities.forEach(item_ => content_.append("Governorate.Cities", item_.toString()));
        if (createdOn !== null && createdOn !== undefined)
            content_.append("CreatedOn", createdOn.toJSON());
        if (categoriesJson !== null && categoriesJson !== undefined)
            content_.append("CategoriesJson", categoriesJson.toString());
        if (categoriesDTO !== null && categoriesDTO !== undefined)
            categoriesDTO.forEach(item_ => content_.append("CategoriesDTO", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantInsertMerchantPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantInsertMerchantPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantInsertMerchantPost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantUpdateMerchantPost(idPath: number, idFormData: number | undefined, code: string | null | undefined, status: MerchantStatus | null | undefined, shopName: string | undefined, slug: string | undefined, description: string | undefined, shortDescription: string | undefined, locationOnMap: string | undefined, address: string | undefined, latitude: number | null | undefined, longitude: number | null | undefined, rating: number | undefined, ratingCount: number | undefined, mobileNo: string | undefined, whatsAppMobileNo: string | undefined, email: string | null | undefined, governorateId: number | null | undefined, cityId: number | null | undefined, isFavoriteMerchant: boolean | undefined, commercialRegistrationNumber: string | undefined, nationalIdNumber: string | undefined, businessHours: string | undefined, logo: string | null | undefined, commercialRegistrationImage: string | null | undefined, nationalIdImage: string | null | undefined, nationalIdImageForm: FileParameter | null | undefined, logoForm: FileParameter | null | undefined, commercialRegistrationImageForm: FileParameter | null | undefined, membersJson: string | null | undefined, members: MemberDTO[] | null | undefined, city_Id: number | undefined, city_NameAr: string | undefined, city_NameEn: string | undefined, governorate_Id: number | undefined, governorate_Name: string | undefined, governorate_CreatedByUserId: number | null | undefined, governorate_CreatedOn: Date | null | undefined, governorate_CreatedByUser_Id: number | undefined, governorate_CreatedByUser_NationalId: string | null | undefined, governorate_CreatedByUser_UserName: string | null | undefined, governorate_CreatedByUser_FullName: string | null | undefined, governorate_CreatedByUser_Email: string | null | undefined, governorate_CreatedByUser_Password: string | null | undefined, governorate_CreatedByUser_Photo: string | null | undefined, governorate_CreatedByUser_UserType: UserTypeEnum | null | undefined, governorate_CreatedByUser_PhoneNumber: string | null | undefined, governorate_CreatedByUser_Address: string | null | undefined, governorate_CreatedByUser_IsActive: boolean | null | undefined, governorate_UpdatedBy: number | null | undefined, governorate_UpdatedOn: Date | null | undefined, governorate_UpdatedByUser_Id: number | undefined, governorate_UpdatedByUser_NationalId: string | null | undefined, governorate_UpdatedByUser_UserName: string | null | undefined, governorate_UpdatedByUser_FullName: string | null | undefined, governorate_UpdatedByUser_Email: string | null | undefined, governorate_UpdatedByUser_Password: string | null | undefined, governorate_UpdatedByUser_Photo: string | null | undefined, governorate_UpdatedByUser_UserType: UserTypeEnum | null | undefined, governorate_UpdatedByUser_PhoneNumber: string | null | undefined, governorate_UpdatedByUser_Address: string | null | undefined, governorate_UpdatedByUser_IsActive: boolean | null | undefined, governorate_Cities: CityDTO[] | undefined, createdOn: Date | null | undefined, categoriesJson: string | null | undefined, categoriesDTO: CategoryDTO[] | null | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/UpdateMerchant/{id}";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (code !== null && code !== undefined)
            content_.append("Code", code.toString());
        if (status !== null && status !== undefined)
            content_.append("Status", status.toString());
        if (shopName === null || shopName === undefined)
            throw new Error("The parameter 'shopName' cannot be null.");
        else
            content_.append("ShopName", shopName.toString());
        if (slug === null || slug === undefined)
            throw new Error("The parameter 'slug' cannot be null.");
        else
            content_.append("Slug", slug.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (shortDescription === null || shortDescription === undefined)
            throw new Error("The parameter 'shortDescription' cannot be null.");
        else
            content_.append("ShortDescription", shortDescription.toString());
        if (locationOnMap === null || locationOnMap === undefined)
            throw new Error("The parameter 'locationOnMap' cannot be null.");
        else
            content_.append("LocationOnMap", locationOnMap.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (latitude !== null && latitude !== undefined)
            content_.append("Latitude", latitude.toString());
        if (longitude !== null && longitude !== undefined)
            content_.append("Longitude", longitude.toString());
        if (rating === null || rating === undefined)
            throw new Error("The parameter 'rating' cannot be null.");
        else
            content_.append("Rating", rating.toString());
        if (ratingCount === null || ratingCount === undefined)
            throw new Error("The parameter 'ratingCount' cannot be null.");
        else
            content_.append("RatingCount", ratingCount.toString());
        if (mobileNo === null || mobileNo === undefined)
            throw new Error("The parameter 'mobileNo' cannot be null.");
        else
            content_.append("MobileNo", mobileNo.toString());
        if (whatsAppMobileNo === null || whatsAppMobileNo === undefined)
            throw new Error("The parameter 'whatsAppMobileNo' cannot be null.");
        else
            content_.append("WhatsAppMobileNo", whatsAppMobileNo.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (governorateId !== null && governorateId !== undefined)
            content_.append("GovernorateId", governorateId.toString());
        if (cityId !== null && cityId !== undefined)
            content_.append("CityId", cityId.toString());
        if (isFavoriteMerchant === null || isFavoriteMerchant === undefined)
            throw new Error("The parameter 'isFavoriteMerchant' cannot be null.");
        else
            content_.append("IsFavoriteMerchant", isFavoriteMerchant.toString());
        if (commercialRegistrationNumber === null || commercialRegistrationNumber === undefined)
            throw new Error("The parameter 'commercialRegistrationNumber' cannot be null.");
        else
            content_.append("CommercialRegistrationNumber", commercialRegistrationNumber.toString());
        if (nationalIdNumber === null || nationalIdNumber === undefined)
            throw new Error("The parameter 'nationalIdNumber' cannot be null.");
        else
            content_.append("NationalIdNumber", nationalIdNumber.toString());
        if (businessHours === null || businessHours === undefined)
            throw new Error("The parameter 'businessHours' cannot be null.");
        else
            content_.append("BusinessHours", businessHours.toString());
        if (logo !== null && logo !== undefined)
            content_.append("Logo", logo.toString());
        if (commercialRegistrationImage !== null && commercialRegistrationImage !== undefined)
            content_.append("CommercialRegistrationImage", commercialRegistrationImage.toString());
        if (nationalIdImage !== null && nationalIdImage !== undefined)
            content_.append("NationalIdImage", nationalIdImage.toString());
        if (nationalIdImageForm !== null && nationalIdImageForm !== undefined)
            content_.append("NationalIdImageForm", nationalIdImageForm.data, nationalIdImageForm.fileName ? nationalIdImageForm.fileName : "NationalIdImageForm");
        if (logoForm !== null && logoForm !== undefined)
            content_.append("LogoForm", logoForm.data, logoForm.fileName ? logoForm.fileName : "LogoForm");
        if (commercialRegistrationImageForm !== null && commercialRegistrationImageForm !== undefined)
            content_.append("CommercialRegistrationImageForm", commercialRegistrationImageForm.data, commercialRegistrationImageForm.fileName ? commercialRegistrationImageForm.fileName : "CommercialRegistrationImageForm");
        if (membersJson !== null && membersJson !== undefined)
            content_.append("MembersJson", membersJson.toString());
        if (members !== null && members !== undefined)
            members.forEach(item_ => content_.append("Members", item_.toString()));
        if (city_Id === null || city_Id === undefined)
            throw new Error("The parameter 'city_Id' cannot be null.");
        else
            content_.append("City.Id", city_Id.toString());
        if (city_NameAr === null || city_NameAr === undefined)
            throw new Error("The parameter 'city_NameAr' cannot be null.");
        else
            content_.append("City.NameAr", city_NameAr.toString());
        if (city_NameEn === null || city_NameEn === undefined)
            throw new Error("The parameter 'city_NameEn' cannot be null.");
        else
            content_.append("City.NameEn", city_NameEn.toString());
        if (governorate_Id === null || governorate_Id === undefined)
            throw new Error("The parameter 'governorate_Id' cannot be null.");
        else
            content_.append("Governorate.Id", governorate_Id.toString());
        if (governorate_Name === null || governorate_Name === undefined)
            throw new Error("The parameter 'governorate_Name' cannot be null.");
        else
            content_.append("Governorate.Name", governorate_Name.toString());
        if (governorate_CreatedByUserId !== null && governorate_CreatedByUserId !== undefined)
            content_.append("Governorate.CreatedByUserId", governorate_CreatedByUserId.toString());
        if (governorate_CreatedOn !== null && governorate_CreatedOn !== undefined)
            content_.append("Governorate.CreatedOn", governorate_CreatedOn.toJSON());
        if (governorate_CreatedByUser_Id === null || governorate_CreatedByUser_Id === undefined)
            throw new Error("The parameter 'governorate_CreatedByUser_Id' cannot be null.");
        else
            content_.append("Governorate.CreatedByUser.Id", governorate_CreatedByUser_Id.toString());
        if (governorate_CreatedByUser_NationalId !== null && governorate_CreatedByUser_NationalId !== undefined)
            content_.append("Governorate.CreatedByUser.NationalId", governorate_CreatedByUser_NationalId.toString());
        if (governorate_CreatedByUser_UserName !== null && governorate_CreatedByUser_UserName !== undefined)
            content_.append("Governorate.CreatedByUser.UserName", governorate_CreatedByUser_UserName.toString());
        if (governorate_CreatedByUser_FullName !== null && governorate_CreatedByUser_FullName !== undefined)
            content_.append("Governorate.CreatedByUser.FullName", governorate_CreatedByUser_FullName.toString());
        if (governorate_CreatedByUser_Email !== null && governorate_CreatedByUser_Email !== undefined)
            content_.append("Governorate.CreatedByUser.Email", governorate_CreatedByUser_Email.toString());
        if (governorate_CreatedByUser_Password !== null && governorate_CreatedByUser_Password !== undefined)
            content_.append("Governorate.CreatedByUser.Password", governorate_CreatedByUser_Password.toString());
        if (governorate_CreatedByUser_Photo !== null && governorate_CreatedByUser_Photo !== undefined)
            content_.append("Governorate.CreatedByUser.Photo", governorate_CreatedByUser_Photo.toString());
        if (governorate_CreatedByUser_UserType !== null && governorate_CreatedByUser_UserType !== undefined)
            content_.append("Governorate.CreatedByUser.UserType", governorate_CreatedByUser_UserType.toString());
        if (governorate_CreatedByUser_PhoneNumber !== null && governorate_CreatedByUser_PhoneNumber !== undefined)
            content_.append("Governorate.CreatedByUser.PhoneNumber", governorate_CreatedByUser_PhoneNumber.toString());
        if (governorate_CreatedByUser_Address !== null && governorate_CreatedByUser_Address !== undefined)
            content_.append("Governorate.CreatedByUser.Address", governorate_CreatedByUser_Address.toString());
        if (governorate_CreatedByUser_IsActive !== null && governorate_CreatedByUser_IsActive !== undefined)
            content_.append("Governorate.CreatedByUser.IsActive", governorate_CreatedByUser_IsActive.toString());
        if (governorate_UpdatedBy !== null && governorate_UpdatedBy !== undefined)
            content_.append("Governorate.UpdatedBy", governorate_UpdatedBy.toString());
        if (governorate_UpdatedOn !== null && governorate_UpdatedOn !== undefined)
            content_.append("Governorate.UpdatedOn", governorate_UpdatedOn.toJSON());
        if (governorate_UpdatedByUser_Id === null || governorate_UpdatedByUser_Id === undefined)
            throw new Error("The parameter 'governorate_UpdatedByUser_Id' cannot be null.");
        else
            content_.append("Governorate.UpdatedByUser.Id", governorate_UpdatedByUser_Id.toString());
        if (governorate_UpdatedByUser_NationalId !== null && governorate_UpdatedByUser_NationalId !== undefined)
            content_.append("Governorate.UpdatedByUser.NationalId", governorate_UpdatedByUser_NationalId.toString());
        if (governorate_UpdatedByUser_UserName !== null && governorate_UpdatedByUser_UserName !== undefined)
            content_.append("Governorate.UpdatedByUser.UserName", governorate_UpdatedByUser_UserName.toString());
        if (governorate_UpdatedByUser_FullName !== null && governorate_UpdatedByUser_FullName !== undefined)
            content_.append("Governorate.UpdatedByUser.FullName", governorate_UpdatedByUser_FullName.toString());
        if (governorate_UpdatedByUser_Email !== null && governorate_UpdatedByUser_Email !== undefined)
            content_.append("Governorate.UpdatedByUser.Email", governorate_UpdatedByUser_Email.toString());
        if (governorate_UpdatedByUser_Password !== null && governorate_UpdatedByUser_Password !== undefined)
            content_.append("Governorate.UpdatedByUser.Password", governorate_UpdatedByUser_Password.toString());
        if (governorate_UpdatedByUser_Photo !== null && governorate_UpdatedByUser_Photo !== undefined)
            content_.append("Governorate.UpdatedByUser.Photo", governorate_UpdatedByUser_Photo.toString());
        if (governorate_UpdatedByUser_UserType !== null && governorate_UpdatedByUser_UserType !== undefined)
            content_.append("Governorate.UpdatedByUser.UserType", governorate_UpdatedByUser_UserType.toString());
        if (governorate_UpdatedByUser_PhoneNumber !== null && governorate_UpdatedByUser_PhoneNumber !== undefined)
            content_.append("Governorate.UpdatedByUser.PhoneNumber", governorate_UpdatedByUser_PhoneNumber.toString());
        if (governorate_UpdatedByUser_Address !== null && governorate_UpdatedByUser_Address !== undefined)
            content_.append("Governorate.UpdatedByUser.Address", governorate_UpdatedByUser_Address.toString());
        if (governorate_UpdatedByUser_IsActive !== null && governorate_UpdatedByUser_IsActive !== undefined)
            content_.append("Governorate.UpdatedByUser.IsActive", governorate_UpdatedByUser_IsActive.toString());
        if (governorate_Cities === null || governorate_Cities === undefined)
            throw new Error("The parameter 'governorate_Cities' cannot be null.");
        else
            governorate_Cities.forEach(item_ => content_.append("Governorate.Cities", item_.toString()));
        if (createdOn !== null && createdOn !== undefined)
            content_.append("CreatedOn", createdOn.toJSON());
        if (categoriesJson !== null && categoriesJson !== undefined)
            content_.append("CategoriesJson", categoriesJson.toString());
        if (categoriesDTO !== null && categoriesDTO !== undefined)
            categoriesDTO.forEach(item_ => content_.append("CategoriesDTO", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantUpdateMerchantPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantUpdateMerchantPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantUpdateMerchantPost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantActivatePut(id: number): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Activate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantActivatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantActivatePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantActivatePut(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantDeactivatePut(id: number): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Deactivate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantDeactivatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantDeactivatePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantDeactivatePut(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantClosePut(id: number): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Close/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantClosePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantClosePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantClosePut(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfMerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfMerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfMerchantDTO>;
        }));
    }

    protected processApiMerchantGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfMerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfMerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantGetDetailsGet(id: number | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantGetDetailsGet(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantInsertPost(entity: MerchantDTO): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantInsertPost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantUpdatePost(entity: MerchantDTO): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantUpdatePost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantDeletePost(id: number | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantDeletePost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsAdvancedSearchPartPost(part: PartFilterViewModel, page: number | undefined, pageSize: number | undefined): Observable<DataSourceResultOfPartDTO> {
        let url_ = this.baseUrl + "/api/Parts/AdvancedSearchPart?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(part);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsAdvancedSearchPartPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsAdvancedSearchPartPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfPartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfPartDTO>;
        }));
    }

    protected processApiPartsAdvancedSearchPartPost(response: HttpResponseBase): Observable<DataSourceResultOfPartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfPartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfPartDTO> {
        let url_ = this.baseUrl + "/api/Parts/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfPartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfPartDTO>;
        }));
    }

    protected processApiPartsGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfPartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfPartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsGetDetailsGet(id: number | undefined): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsGetDetailsGet(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsInsertPost(entity: PartDTO): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsInsertPost(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsUpdatePost(entity: PartDTO): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsUpdatePost(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsDeletePost(id: number | undefined): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsDeletePost(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountLoginPost(loginViewModel: LoginViewModel): Observable<AuthDto> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountLoginPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountLoginPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthDto>;
        }));
    }

    protected processApiAccountLoginPost(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountRegisterNewUserPost(registerViewModel: RegisterViewModel): Observable<AuthDto> {
        let url_ = this.baseUrl + "/api/Account/RegisterNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountRegisterNewUserPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountRegisterNewUserPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthDto>;
        }));
    }

    protected processApiAccountRegisterNewUserPost(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountRegisterNewVisitorPost(visitorViewModel: VisitorViewModel): Observable<AuthDto> {
        let url_ = this.baseUrl + "/api/Account/RegisterNewVisitor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(visitorViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountRegisterNewVisitorPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountRegisterNewVisitorPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthDto>;
        }));
    }

    protected processApiAccountRegisterNewVisitorPost(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountSetUserActiveStatusPatch(id: number, isActive: boolean | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/SetUserActiveStatus/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountSetUserActiveStatusPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountSetUserActiveStatusPatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processApiAccountSetUserActiveStatusPatch(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfUserDTO> {
        let url_ = this.baseUrl + "/api/Account/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfUserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfUserDTO>;
        }));
    }

    protected processApiAccountGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfUserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfUserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountGetDetailsGet(id: number | undefined): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountGetDetailsGet(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountInsertPost(entity: UserDTO): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountInsertPost(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountUpdatePost(entity: UserDTO): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountUpdatePost(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountDeletePost(id: number | undefined): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountDeletePost(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiBrandActiveOrDeactiveBrandPost(brandId: number | undefined, action: boolean | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Brand/ActiveOrDeactiveBrand?";
        if (brandId === null)
            throw new Error("The parameter 'brandId' cannot be null.");
        else if (brandId !== undefined)
            url_ += "brandId=" + encodeURIComponent("" + brandId) + "&";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBrandActiveOrDeactiveBrandPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBrandActiveOrDeactiveBrandPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiBrandActiveOrDeactiveBrandPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiBrandGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfBrandDTO> {
        let url_ = this.baseUrl + "/api/Brand/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBrandGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBrandGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfBrandDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfBrandDTO>;
        }));
    }

    protected processApiBrandGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfBrandDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfBrandDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiBrandGetDetailsGet(id: number | undefined): Observable<BrandDTO> {
        let url_ = this.baseUrl + "/api/Brand/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBrandGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBrandGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDTO>;
        }));
    }

    protected processApiBrandGetDetailsGet(response: HttpResponseBase): Observable<BrandDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiBrandInsertPost(entity: BrandDTO): Observable<BrandDTO> {
        let url_ = this.baseUrl + "/api/Brand/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBrandInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBrandInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDTO>;
        }));
    }

    protected processApiBrandInsertPost(response: HttpResponseBase): Observable<BrandDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiBrandUpdatePost(entity: BrandDTO): Observable<BrandDTO> {
        let url_ = this.baseUrl + "/api/Brand/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBrandUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBrandUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDTO>;
        }));
    }

    protected processApiBrandUpdatePost(response: HttpResponseBase): Observable<BrandDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiBrandDeletePost(id: number | undefined): Observable<BrandDTO> {
        let url_ = this.baseUrl + "/api/Brand/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBrandDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBrandDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDTO>;
        }));
    }

    protected processApiBrandDeletePost(response: HttpResponseBase): Observable<BrandDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoryAllGet(): Observable<CategoryDTO[]> {
        let url_ = this.baseUrl + "/api/Category/All";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoryAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoryAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO[]>;
        }));
    }

    protected processApiCategoryAllGet(response: HttpResponseBase): Observable<CategoryDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfCityDTO> {
        let url_ = this.baseUrl + "/api/City/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfCityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfCityDTO>;
        }));
    }

    protected processApiCityGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfCityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfCityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityGetDetailsGet(id: number | undefined): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityGetDetailsGet(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityInsertPost(entity: CityDTO): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityInsertPost(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityUpdatePost(entity: CityDTO): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityUpdatePost(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityDeletePost(id: number | undefined): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityDeletePost(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiFileUploadFilePost(file: FileParameter | undefined, fileType: FileTypeEnum | undefined): Observable<UploadDTO> {
        let url_ = this.baseUrl + "/api/File/UploadFile?";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiFileUploadFilePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiFileUploadFilePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadDTO>;
        }));
    }

    protected processApiFileUploadFilePost(response: HttpResponseBase): Observable<UploadDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiFileDeleteFilePost(fileName: string | undefined, fileType: FileTypeEnum | undefined): Observable<UploadDTO> {
        let url_ = this.baseUrl + "/api/File/DeleteFile?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiFileDeleteFilePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiFileDeleteFilePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadDTO>;
        }));
    }

    protected processApiFileDeleteFilePost(response: HttpResponseBase): Observable<UploadDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetLookupGet(lookupName: string | undefined, searchTerm: string | null | undefined): Observable<LookupDTO[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetLookup?";
        if (lookupName === null)
            throw new Error("The parameter 'lookupName' cannot be null.");
        else if (lookupName !== undefined)
            url_ += "lookupName=" + encodeURIComponent("" + lookupName) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetLookupGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetLookupGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupDTO[]>;
        }));
    }

    protected processApiLookupGetLookupGet(response: HttpResponseBase): Observable<LookupDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGovernoratesGet(): Observable<GovernorateLookupDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Governorates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGovernoratesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGovernoratesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateLookupDto[]>;
        }));
    }

    protected processApiLookupGovernoratesGet(response: HttpResponseBase): Observable<GovernorateLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GovernorateLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupCitiesGet(governorateId: number | null | undefined): Observable<CityLookupDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Cities?";
        if (governorateId !== undefined && governorateId !== null)
            url_ += "governorateId=" + encodeURIComponent("" + governorateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupCitiesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupCitiesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityLookupDto[]>;
        }));
    }

    protected processApiLookupCitiesGet(response: HttpResponseBase): Observable<CityLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiModelTypeGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfModelTypeDTO> {
        let url_ = this.baseUrl + "/api/ModelType/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiModelTypeGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiModelTypeGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfModelTypeDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfModelTypeDTO>;
        }));
    }

    protected processApiModelTypeGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfModelTypeDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfModelTypeDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiModelTypeGetDetailsGet(id: number | undefined): Observable<ModelTypeDTO> {
        let url_ = this.baseUrl + "/api/ModelType/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiModelTypeGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiModelTypeGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModelTypeDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModelTypeDTO>;
        }));
    }

    protected processApiModelTypeGetDetailsGet(response: HttpResponseBase): Observable<ModelTypeDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModelTypeDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiModelTypeInsertPost(entity: ModelTypeDTO): Observable<ModelTypeDTO> {
        let url_ = this.baseUrl + "/api/ModelType/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiModelTypeInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiModelTypeInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModelTypeDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModelTypeDTO>;
        }));
    }

    protected processApiModelTypeInsertPost(response: HttpResponseBase): Observable<ModelTypeDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModelTypeDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiModelTypeUpdatePost(entity: ModelTypeDTO): Observable<ModelTypeDTO> {
        let url_ = this.baseUrl + "/api/ModelType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiModelTypeUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiModelTypeUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModelTypeDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModelTypeDTO>;
        }));
    }

    protected processApiModelTypeUpdatePost(response: HttpResponseBase): Observable<ModelTypeDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModelTypeDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiModelTypeDeletePost(id: number | undefined): Observable<ModelTypeDTO> {
        let url_ = this.baseUrl + "/api/ModelType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiModelTypeDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiModelTypeDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModelTypeDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModelTypeDTO>;
        }));
    }

    protected processApiModelTypeDeletePost(response: HttpResponseBase): Observable<ModelTypeDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModelTypeDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPermissionGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfPermissionDTO> {
        let url_ = this.baseUrl + "/api/Permission/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfPermissionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfPermissionDTO>;
        }));
    }

    protected processApiPermissionGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfPermissionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfPermissionDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPermissionGetDetailsGet(id: number | undefined): Observable<PermissionDTO> {
        let url_ = this.baseUrl + "/api/Permission/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDTO>;
        }));
    }

    protected processApiPermissionGetDetailsGet(response: HttpResponseBase): Observable<PermissionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPermissionInsertPost(entity: PermissionDTO): Observable<PermissionDTO> {
        let url_ = this.baseUrl + "/api/Permission/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDTO>;
        }));
    }

    protected processApiPermissionInsertPost(response: HttpResponseBase): Observable<PermissionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPermissionUpdatePost(entity: PermissionDTO): Observable<PermissionDTO> {
        let url_ = this.baseUrl + "/api/Permission/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDTO>;
        }));
    }

    protected processApiPermissionUpdatePost(response: HttpResponseBase): Observable<PermissionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPermissionDeletePost(id: number | undefined): Observable<PermissionDTO> {
        let url_ = this.baseUrl + "/api/Permission/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDTO>;
        }));
    }

    protected processApiPermissionDeletePost(response: HttpResponseBase): Observable<PermissionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiRoleGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfRoleDTO> {
        let url_ = this.baseUrl + "/api/Role/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRoleGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRoleGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfRoleDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfRoleDTO>;
        }));
    }

    protected processApiRoleGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfRoleDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfRoleDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiRoleGetDetailsGet(id: number | undefined): Observable<RoleDTO> {
        let url_ = this.baseUrl + "/api/Role/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRoleGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRoleGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDTO>;
        }));
    }

    protected processApiRoleGetDetailsGet(response: HttpResponseBase): Observable<RoleDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiRoleInsertPost(entity: RoleDTO): Observable<RoleDTO> {
        let url_ = this.baseUrl + "/api/Role/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRoleInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRoleInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDTO>;
        }));
    }

    protected processApiRoleInsertPost(response: HttpResponseBase): Observable<RoleDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiRoleUpdatePost(entity: RoleDTO): Observable<RoleDTO> {
        let url_ = this.baseUrl + "/api/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRoleUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRoleUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDTO>;
        }));
    }

    protected processApiRoleUpdatePost(response: HttpResponseBase): Observable<RoleDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiRoleDeletePost(id: number | undefined): Observable<RoleDTO> {
        let url_ = this.baseUrl + "/api/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRoleDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRoleDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDTO>;
        }));
    }

    protected processApiRoleDeletePost(response: HttpResponseBase): Observable<RoleDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class DataSourceResultOfCategoryDTO implements IDataSourceResultOfCategoryDTO {
    data!: CategoryDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfCategoryDTO {
    data: CategoryDTO[];
    count: number;
    additionalValue: number;
}

export class CategoryDTO implements ICategoryDTO {
    id!: number;
    name!: string;

    constructor(data?: ICategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICategoryDTO {
    id: number;
    name: string;
}

export class MerchantDTO implements IMerchantDTO {
    id!: number;
    code?: string | undefined;
    status?: MerchantStatus | undefined;
    shopName!: string;
    slug!: string;
    description!: string;
    shortDescription!: string;
    locationOnMap!: string;
    address!: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    rating!: number;
    ratingCount!: number;
    mobileNo!: string;
    whatsAppMobileNo!: string;
    email?: string | undefined;
    governorateId?: number | undefined;
    cityId?: number | undefined;
    isFavoriteMerchant!: boolean;
    commercialRegistrationNumber!: string;
    nationalIdNumber!: string;
    businessHours!: string;
    logo?: string | undefined;
    commercialRegistrationImage?: string | undefined;
    nationalIdImage?: string | undefined;
    nationalIdImageForm?: any | undefined;
    logoForm?: any | undefined;
    commercialRegistrationImageForm?: any | undefined;
    membersJson?: string | undefined;
    members?: MemberDTO[] | undefined;
    city?: CityDTO | undefined;
    governorate?: GovernorateDTO | undefined;
    createdOn?: Date | undefined;
    categoriesJson?: string | undefined;
    categoriesDTO?: CategoryDTO[] | undefined;

    constructor(data?: IMerchantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.status = _data["status"];
            this.shopName = _data["shopName"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.locationOnMap = _data["locationOnMap"];
            this.address = _data["address"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.rating = _data["rating"];
            this.ratingCount = _data["ratingCount"];
            this.mobileNo = _data["mobileNo"];
            this.whatsAppMobileNo = _data["whatsAppMobileNo"];
            this.email = _data["email"];
            this.governorateId = _data["governorateId"];
            this.cityId = _data["cityId"];
            this.isFavoriteMerchant = _data["isFavoriteMerchant"];
            this.commercialRegistrationNumber = _data["commercialRegistrationNumber"];
            this.nationalIdNumber = _data["nationalIdNumber"];
            this.businessHours = _data["businessHours"];
            this.logo = _data["logo"];
            this.commercialRegistrationImage = _data["commercialRegistrationImage"];
            this.nationalIdImage = _data["nationalIdImage"];
            this.nationalIdImageForm = _data["nationalIdImageForm"];
            this.logoForm = _data["logoForm"];
            this.commercialRegistrationImageForm = _data["commercialRegistrationImageForm"];
            this.membersJson = _data["membersJson"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(MemberDTO.fromJS(item));
            }
            this.city = _data["city"] ? CityDTO.fromJS(_data["city"]) : <any>undefined;
            this.governorate = _data["governorate"] ? GovernorateDTO.fromJS(_data["governorate"]) : <any>undefined;
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.categoriesJson = _data["categoriesJson"];
            if (Array.isArray(_data["categoriesDTO"])) {
                this.categoriesDTO = [] as any;
                for (let item of _data["categoriesDTO"])
                    this.categoriesDTO!.push(CategoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MerchantDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["status"] = this.status;
        data["shopName"] = this.shopName;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["locationOnMap"] = this.locationOnMap;
        data["address"] = this.address;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["rating"] = this.rating;
        data["ratingCount"] = this.ratingCount;
        data["mobileNo"] = this.mobileNo;
        data["whatsAppMobileNo"] = this.whatsAppMobileNo;
        data["email"] = this.email;
        data["governorateId"] = this.governorateId;
        data["cityId"] = this.cityId;
        data["isFavoriteMerchant"] = this.isFavoriteMerchant;
        data["commercialRegistrationNumber"] = this.commercialRegistrationNumber;
        data["nationalIdNumber"] = this.nationalIdNumber;
        data["businessHours"] = this.businessHours;
        data["logo"] = this.logo;
        data["commercialRegistrationImage"] = this.commercialRegistrationImage;
        data["nationalIdImage"] = this.nationalIdImage;
        data["nationalIdImageForm"] = this.nationalIdImageForm;
        data["logoForm"] = this.logoForm;
        data["commercialRegistrationImageForm"] = this.commercialRegistrationImageForm;
        data["membersJson"] = this.membersJson;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item.toJSON());
        }
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["governorate"] = this.governorate ? this.governorate.toJSON() : <any>undefined;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["categoriesJson"] = this.categoriesJson;
        if (Array.isArray(this.categoriesDTO)) {
            data["categoriesDTO"] = [];
            for (let item of this.categoriesDTO)
                data["categoriesDTO"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMerchantDTO {
    id: number;
    code?: string | undefined;
    status?: MerchantStatus | undefined;
    shopName: string;
    slug: string;
    description: string;
    shortDescription: string;
    locationOnMap: string;
    address: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    rating: number;
    ratingCount: number;
    mobileNo: string;
    whatsAppMobileNo: string;
    email?: string | undefined;
    governorateId?: number | undefined;
    cityId?: number | undefined;
    isFavoriteMerchant: boolean;
    commercialRegistrationNumber: string;
    nationalIdNumber: string;
    businessHours: string;
    logo?: string | undefined;
    commercialRegistrationImage?: string | undefined;
    nationalIdImage?: string | undefined;
    nationalIdImageForm?: any | undefined;
    logoForm?: any | undefined;
    commercialRegistrationImageForm?: any | undefined;
    membersJson?: string | undefined;
    members?: MemberDTO[] | undefined;
    city?: CityDTO | undefined;
    governorate?: GovernorateDTO | undefined;
    createdOn?: Date | undefined;
    categoriesJson?: string | undefined;
    categoriesDTO?: CategoryDTO[] | undefined;
}

export enum MerchantStatus {
    Active = 1,
    Inactive = 2,
    Deleted = 3,
}

export class MemberDTO implements IMemberDTO {
    id!: number;
    userId!: number;
    merchantId!: number;
    role!: string;
    merchantMember!: UserDTO;

    constructor(data?: IMemberDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.merchantMember = new UserDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.merchantId = _data["merchantId"];
            this.role = _data["role"];
            this.merchantMember = _data["merchantMember"] ? UserDTO.fromJS(_data["merchantMember"]) : new UserDTO();
        }
    }

    static fromJS(data: any): MemberDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["merchantId"] = this.merchantId;
        data["role"] = this.role;
        data["merchantMember"] = this.merchantMember ? this.merchantMember.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMemberDTO {
    id: number;
    userId: number;
    merchantId: number;
    role: string;
    merchantMember: UserDTO;
}

export class UserDTO implements IUserDTO {
    id!: number;
    nationalId?: string | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    photo?: string | undefined;
    userType?: UserTypeEnum | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nationalId = _data["nationalId"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.photo = _data["photo"];
            this.userType = _data["userType"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nationalId"] = this.nationalId;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["photo"] = this.photo;
        data["userType"] = this.userType;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUserDTO {
    id: number;
    nationalId?: string | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    photo?: string | undefined;
    userType?: UserTypeEnum | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    isActive?: boolean | undefined;
}

export enum UserTypeEnum {
    Admin = 1,
    Client = 2,
    Merchant = 3,
    ShippingCompany = 4,
}

export class CityDTO implements ICityDTO {
    id!: number;
    nameAr!: string;
    nameEn!: string;

    constructor(data?: ICityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
        }
    }

    static fromJS(data: any): CityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        return data;
    }
}

export interface ICityDTO {
    id: number;
    nameAr: string;
    nameEn: string;
}

export class GovernorateDTO implements IGovernorateDTO {
    id!: number;
    name!: string;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;
    createdByUser!: UserDTO;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    updatedByUser!: UserDTO;
    cities!: CityDTO[];

    constructor(data?: IGovernorateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdByUser = new UserDTO();
            this.updatedByUser = new UserDTO();
            this.cities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.createdByUserId = _data["createdByUserId"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.createdByUser = _data["createdByUser"] ? UserDTO.fromJS(_data["createdByUser"]) : new UserDTO();
            this.updatedBy = _data["updatedBy"];
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            this.updatedByUser = _data["updatedByUser"] ? UserDTO.fromJS(_data["updatedByUser"]) : new UserDTO();
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities!.push(CityDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GovernorateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GovernorateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["createdByUserId"] = this.createdByUserId;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : <any>undefined;
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGovernorateDTO {
    id: number;
    name: string;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;
    createdByUser: UserDTO;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    updatedByUser: UserDTO;
    cities: CityDTO[];
}

export class DataSourceResultOfMerchantDTO implements IDataSourceResultOfMerchantDTO {
    data!: MerchantDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfMerchantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MerchantDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfMerchantDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfMerchantDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfMerchantDTO {
    data: MerchantDTO[];
    count: number;
    additionalValue: number;
}

export class DataSourceResultOfPartDTO implements IDataSourceResultOfPartDTO {
    data!: PartDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfPartDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PartDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfPartDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfPartDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfPartDTO {
    data: PartDTO[];
    count: number;
    additionalValue: number;
}

export class PartDTO implements IPartDTO {
    id!: number;
    name!: string;
    description!: string;
    price!: number;
    finalPrice!: number;
    condition!: PartConditionEnum;
    conditionName!: string;
    imageUrl!: string;
    isSold!: boolean;
    isFavorit!: boolean;
    isDelivery!: boolean;
    discount!: number;
    quality!: PartQualityEnum;
    qualityName!: string;
    partType!: PartTypeEnum;
    partTypeName!: string;
    yearOfManufacture!: number;
    merchantId?: number | undefined;
    merchantName!: string;
    categoryId!: number;
    categoryName!: string;
    carModelId?: number | undefined;
    carModelName?: string | undefined;
    carModelTypeId?: number | undefined;
    carModelTypeName?: string | undefined;
    countryOfManufactureId?: number | undefined;
    countryOfManufactureName?: string | undefined;
    count!: number;

    constructor(data?: IPartDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.finalPrice = _data["finalPrice"];
            this.condition = _data["condition"];
            this.conditionName = _data["conditionName"];
            this.imageUrl = _data["imageUrl"];
            this.isSold = _data["isSold"];
            this.isFavorit = _data["isFavorit"];
            this.isDelivery = _data["isDelivery"];
            this.discount = _data["discount"];
            this.quality = _data["quality"];
            this.qualityName = _data["qualityName"];
            this.partType = _data["partType"];
            this.partTypeName = _data["partTypeName"];
            this.yearOfManufacture = _data["yearOfManufacture"];
            this.merchantId = _data["merchantId"];
            this.merchantName = _data["merchantName"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.carModelId = _data["carModelId"];
            this.carModelName = _data["carModelName"];
            this.carModelTypeId = _data["carModelTypeId"];
            this.carModelTypeName = _data["carModelTypeName"];
            this.countryOfManufactureId = _data["countryOfManufactureId"];
            this.countryOfManufactureName = _data["countryOfManufactureName"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): PartDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PartDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["finalPrice"] = this.finalPrice;
        data["condition"] = this.condition;
        data["conditionName"] = this.conditionName;
        data["imageUrl"] = this.imageUrl;
        data["isSold"] = this.isSold;
        data["isFavorit"] = this.isFavorit;
        data["isDelivery"] = this.isDelivery;
        data["discount"] = this.discount;
        data["quality"] = this.quality;
        data["qualityName"] = this.qualityName;
        data["partType"] = this.partType;
        data["partTypeName"] = this.partTypeName;
        data["yearOfManufacture"] = this.yearOfManufacture;
        data["merchantId"] = this.merchantId;
        data["merchantName"] = this.merchantName;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["carModelId"] = this.carModelId;
        data["carModelName"] = this.carModelName;
        data["carModelTypeId"] = this.carModelTypeId;
        data["carModelTypeName"] = this.carModelTypeName;
        data["countryOfManufactureId"] = this.countryOfManufactureId;
        data["countryOfManufactureName"] = this.countryOfManufactureName;
        data["count"] = this.count;
        return data;
    }
}

export interface IPartDTO {
    id: number;
    name: string;
    description: string;
    price: number;
    finalPrice: number;
    condition: PartConditionEnum;
    conditionName: string;
    imageUrl: string;
    isSold: boolean;
    isFavorit: boolean;
    isDelivery: boolean;
    discount: number;
    quality: PartQualityEnum;
    qualityName: string;
    partType: PartTypeEnum;
    partTypeName: string;
    yearOfManufacture: number;
    merchantId?: number | undefined;
    merchantName: string;
    categoryId: number;
    categoryName: string;
    carModelId?: number | undefined;
    carModelName?: string | undefined;
    carModelTypeId?: number | undefined;
    carModelTypeName?: string | undefined;
    countryOfManufactureId?: number | undefined;
    countryOfManufactureName?: string | undefined;
    count: number;
}

export enum PartConditionEnum {
    New = 1,
    Used = 2,
    Refurbished = 3,
}

export enum PartQualityEnum {
    FirstSort = 1,
    SecondSort = 2,
}

export enum PartTypeEnum {
    Original = 1,
    HighCopy = 2,
    Imitation = 3,
}

export class PartFilterViewModel implements IPartFilterViewModel {
    carModel!: number;
    carModelType!: number;
    yearOfManufactureFrom!: number;
    yearOfManufactureTo!: number;
    partCondition!: number;
    partQuality!: number;
    partType!: number;
    priceFrom!: number;
    priceTo!: number;
    countryOfManufacture!: number;
    quantityFrom!: number;
    quantityTo!: number;
    createdOn?: Date | undefined;
    isSold!: boolean;
    isFavorit!: boolean;
    isDelivery!: boolean;
    partCount?: number | undefined;

    constructor(data?: IPartFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.carModel = _data["carModel"];
            this.carModelType = _data["carModelType"];
            this.yearOfManufactureFrom = _data["yearOfManufactureFrom"];
            this.yearOfManufactureTo = _data["yearOfManufactureTo"];
            this.partCondition = _data["partCondition"];
            this.partQuality = _data["partQuality"];
            this.partType = _data["partType"];
            this.priceFrom = _data["priceFrom"];
            this.priceTo = _data["priceTo"];
            this.countryOfManufacture = _data["countryOfManufacture"];
            this.quantityFrom = _data["quantityFrom"];
            this.quantityTo = _data["quantityTo"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.isSold = _data["isSold"];
            this.isFavorit = _data["isFavorit"];
            this.isDelivery = _data["isDelivery"];
            this.partCount = _data["partCount"];
        }
    }

    static fromJS(data: any): PartFilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PartFilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["carModel"] = this.carModel;
        data["carModelType"] = this.carModelType;
        data["yearOfManufactureFrom"] = this.yearOfManufactureFrom;
        data["yearOfManufactureTo"] = this.yearOfManufactureTo;
        data["partCondition"] = this.partCondition;
        data["partQuality"] = this.partQuality;
        data["partType"] = this.partType;
        data["priceFrom"] = this.priceFrom;
        data["priceTo"] = this.priceTo;
        data["countryOfManufacture"] = this.countryOfManufacture;
        data["quantityFrom"] = this.quantityFrom;
        data["quantityTo"] = this.quantityTo;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["isSold"] = this.isSold;
        data["isFavorit"] = this.isFavorit;
        data["isDelivery"] = this.isDelivery;
        data["partCount"] = this.partCount;
        return data;
    }
}

export interface IPartFilterViewModel {
    carModel: number;
    carModelType: number;
    yearOfManufactureFrom: number;
    yearOfManufactureTo: number;
    partCondition: number;
    partQuality: number;
    partType: number;
    priceFrom: number;
    priceTo: number;
    countryOfManufacture: number;
    quantityFrom: number;
    quantityTo: number;
    createdOn?: Date | undefined;
    isSold: boolean;
    isFavorit: boolean;
    isDelivery: boolean;
    partCount?: number | undefined;
}

export class AuthDto implements IAuthDto {
    userId!: number;
    userName!: string;
    fullName!: string;
    phoneNumber?: string | undefined;
    photo?: string | undefined;
    token!: string;
    message!: string;
    statusCode?: number | undefined;
    isAuthenticated!: boolean;
    isAdmin!: boolean;
    userType!: UserTypeEnum;
    userTypeName!: string;
    roleId?: number | undefined;
    roleName?: string | undefined;
    permissions?: string[] | undefined;

    constructor(data?: IAuthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.photo = _data["photo"];
            this.token = _data["token"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.isAdmin = _data["isAdmin"];
            this.userType = _data["userType"];
            this.userTypeName = _data["userTypeName"];
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): AuthDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["photo"] = this.photo;
        data["token"] = this.token;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["isAuthenticated"] = this.isAuthenticated;
        data["isAdmin"] = this.isAdmin;
        data["userType"] = this.userType;
        data["userTypeName"] = this.userTypeName;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IAuthDto {
    userId: number;
    userName: string;
    fullName: string;
    phoneNumber?: string | undefined;
    photo?: string | undefined;
    token: string;
    message: string;
    statusCode?: number | undefined;
    isAuthenticated: boolean;
    isAdmin: boolean;
    userType: UserTypeEnum;
    userTypeName: string;
    roleId?: number | undefined;
    roleName?: string | undefined;
    permissions?: string[] | undefined;
}

export class LoginViewModel implements ILoginViewModel {
    email!: string;
    password!: string;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginViewModel {
    email: string;
    password: string;
}

export class RegisterViewModel implements IRegisterViewModel {
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    photo?: string | undefined;
    address?: string | undefined;
    userType!: UserTypeEnum;
    roleId?: number | undefined;

    constructor(data?: IRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.photo = _data["photo"];
            this.address = _data["address"];
            this.userType = _data["userType"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): RegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["photo"] = this.photo;
        data["address"] = this.address;
        data["userType"] = this.userType;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IRegisterViewModel {
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    photo?: string | undefined;
    address?: string | undefined;
    userType: UserTypeEnum;
    roleId?: number | undefined;
}

export class VisitorViewModel implements IVisitorViewModel {
    userName!: string;
    fullName!: string;
    email!: string;
    phoneNumber!: string;
    address!: string;

    constructor(data?: IVisitorViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): VisitorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new VisitorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        return data;
    }
}

export interface IVisitorViewModel {
    userName: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    address: string;
}

export class DataSourceResultOfUserDTO implements IDataSourceResultOfUserDTO {
    data!: UserDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfUserDTO {
    data: UserDTO[];
    count: number;
    additionalValue: number;
}

export class DataSourceResultOfBrandDTO implements IDataSourceResultOfBrandDTO {
    data!: BrandDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfBrandDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(BrandDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfBrandDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfBrandDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfBrandDTO {
    data: BrandDTO[];
    count: number;
    additionalValue: number;
}

export class BrandDTO implements IBrandDTO {
    id!: number;
    name!: string;
    code!: string;
    imageUrl!: string;
    partsCount?: number | undefined;
    modelTypesCount?: number | undefined;
    isActive?: boolean | undefined;
    parts?: PartDTO[] | undefined;
    modelTypes?: ModelTypeDTO[] | undefined;

    constructor(data?: IBrandDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.imageUrl = _data["imageUrl"];
            this.partsCount = _data["partsCount"];
            this.modelTypesCount = _data["modelTypesCount"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["parts"])) {
                this.parts = [] as any;
                for (let item of _data["parts"])
                    this.parts!.push(PartDTO.fromJS(item));
            }
            if (Array.isArray(_data["modelTypes"])) {
                this.modelTypes = [] as any;
                for (let item of _data["modelTypes"])
                    this.modelTypes!.push(ModelTypeDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrandDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["imageUrl"] = this.imageUrl;
        data["partsCount"] = this.partsCount;
        data["modelTypesCount"] = this.modelTypesCount;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.parts)) {
            data["parts"] = [];
            for (let item of this.parts)
                data["parts"].push(item.toJSON());
        }
        if (Array.isArray(this.modelTypes)) {
            data["modelTypes"] = [];
            for (let item of this.modelTypes)
                data["modelTypes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBrandDTO {
    id: number;
    name: string;
    code: string;
    imageUrl: string;
    partsCount?: number | undefined;
    modelTypesCount?: number | undefined;
    isActive?: boolean | undefined;
    parts?: PartDTO[] | undefined;
    modelTypes?: ModelTypeDTO[] | undefined;
}

export class ModelTypeDTO implements IModelTypeDTO {
    id!: number;
    name!: string;
    year!: number;
    brandId!: number;
    brand!: BrandDTO;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;

    constructor(data?: IModelTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.brand = new BrandDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.year = _data["year"];
            this.brandId = _data["brandId"];
            this.brand = _data["brand"] ? BrandDTO.fromJS(_data["brand"]) : new BrandDTO();
            this.createdByUserId = _data["createdByUserId"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ModelTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ModelTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["year"] = this.year;
        data["brandId"] = this.brandId;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["createdByUserId"] = this.createdByUserId;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IModelTypeDTO {
    id: number;
    name: string;
    year: number;
    brandId: number;
    brand: BrandDTO;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;
}

export class DataSourceResultOfCityDTO implements IDataSourceResultOfCityDTO {
    data!: CityDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfCityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CityDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfCityDTO {
    data: CityDTO[];
    count: number;
    additionalValue: number;
}

export class UploadDTO implements IUploadDTO {
    fileName?: string | undefined;
    fileSize?: string | undefined;
    successfully_Uploaded!: boolean;
    successfully_Deleted!: boolean;
    message?: string | undefined;

    constructor(data?: IUploadDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.successfully_Uploaded = _data["successfully_Uploaded"];
            this.successfully_Deleted = _data["successfully_Deleted"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): UploadDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["successfully_Uploaded"] = this.successfully_Uploaded;
        data["successfully_Deleted"] = this.successfully_Deleted;
        data["message"] = this.message;
        return data;
    }
}

export interface IUploadDTO {
    fileName?: string | undefined;
    fileSize?: string | undefined;
    successfully_Uploaded: boolean;
    successfully_Deleted: boolean;
    message?: string | undefined;
}

export enum FileTypeEnum {
    Parts = 1,
    Users = 2,
    Brands = 3,
}

export class LookupDTO implements ILookupDTO {
    id!: any;
    text!: string;

    constructor(data?: ILookupDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): LookupDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data;
    }
}

export interface ILookupDTO {
    id: any;
    text: string;
}

export class GovernorateLookupDto implements IGovernorateLookupDto {
    id!: number;
    name!: string;

    constructor(data?: IGovernorateLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GovernorateLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GovernorateLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGovernorateLookupDto {
    id: number;
    name: string;
}

export class CityLookupDto implements ICityLookupDto {
    id!: number;
    nameAr!: string;
    governorateId!: number;

    constructor(data?: ICityLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameAr = _data["nameAr"];
            this.governorateId = _data["governorateId"];
        }
    }

    static fromJS(data: any): CityLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameAr"] = this.nameAr;
        data["governorateId"] = this.governorateId;
        return data;
    }
}

export interface ICityLookupDto {
    id: number;
    nameAr: string;
    governorateId: number;
}

export class DataSourceResultOfModelTypeDTO implements IDataSourceResultOfModelTypeDTO {
    data!: ModelTypeDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfModelTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ModelTypeDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfModelTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfModelTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfModelTypeDTO {
    data: ModelTypeDTO[];
    count: number;
    additionalValue: number;
}

export class DataSourceResultOfPermissionDTO implements IDataSourceResultOfPermissionDTO {
    data!: PermissionDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfPermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PermissionDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfPermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfPermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfPermissionDTO {
    data: PermissionDTO[];
    count: number;
    additionalValue: number;
}

export class PermissionDTO implements IPermissionDTO {
    id!: number;
    permissionNameAr!: string;
    permissionNameEn!: string;
    permissionCode!: string;

    constructor(data?: IPermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.permissionNameAr = _data["permissionNameAr"];
            this.permissionNameEn = _data["permissionNameEn"];
            this.permissionCode = _data["permissionCode"];
        }
    }

    static fromJS(data: any): PermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["permissionNameAr"] = this.permissionNameAr;
        data["permissionNameEn"] = this.permissionNameEn;
        data["permissionCode"] = this.permissionCode;
        return data;
    }
}

export interface IPermissionDTO {
    id: number;
    permissionNameAr: string;
    permissionNameEn: string;
    permissionCode: string;
}

export class DataSourceResultOfRoleDTO implements IDataSourceResultOfRoleDTO {
    data!: RoleDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RoleDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfRoleDTO {
    data: RoleDTO[];
    count: number;
    additionalValue: number;
}

export class RoleDTO implements IRoleDTO {
    id!: number;
    roleNameAr!: string;
    roleNameEn!: string;

    constructor(data?: IRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleNameAr = _data["roleNameAr"];
            this.roleNameEn = _data["roleNameEn"];
        }
    }

    static fromJS(data: any): RoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleNameAr"] = this.roleNameAr;
        data["roleNameEn"] = this.roleNameEn;
        return data;
    }
}

export interface IRoleDTO {
    id: number;
    roleNameAr: string;
    roleNameEn: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}