//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class SwaggerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:5200";
    }

    apiCategoriesGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfCategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfCategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfCategoryDTO>;
        }));
    }

    protected processApiCategoriesGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfCategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfCategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesGetDetailsGet(id: number | undefined): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO>;
        }));
    }

    protected processApiCategoriesGetDetailsGet(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesInsertPost(entity: CategoryDTO): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO>;
        }));
    }

    protected processApiCategoriesInsertPost(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesUpdatePost(entity: CategoryDTO): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO>;
        }));
    }

    protected processApiCategoriesUpdatePost(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoriesDeletePost(id: number | undefined): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Categories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoriesDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoriesDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO>;
        }));
    }

    protected processApiCategoriesDeletePost(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantGetDataByIdGet(id: number): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/GetDataById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantGetDataByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantGetDataByIdGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantGetDataByIdGet(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantInsertMerchantPost(id: number | undefined, shopName: string | undefined, slug: string | undefined, description: string | undefined, shortDescription: string | undefined, locationOnMap: string | undefined, address: string | undefined, latitude: number | null | undefined, longitude: number | null | undefined, rating: number | undefined, ratingCount: number | undefined, mobileNo: string | undefined, whatsAppMobileNo: string | undefined, email: string | null | undefined, governorateId: number | null | undefined, cityId: number | null | undefined, isFavoriteMerchant: boolean | undefined, commercialRegistrationNumber: string | undefined, nationalIdNumber: string | undefined, businessHours: string | undefined, logo: string | null | undefined, commercialRegistrationImage: string | null | undefined, nationalIdImage: string | null | undefined, nationalIdImageForm: FileParameter | undefined, logoForm: FileParameter | undefined, commercialRegistrationImageForm: FileParameter | undefined, membersJson: string | null | undefined, members: MemberDTO[] | null | undefined, city_Id: number | undefined, city_NameAr: string | undefined, city_NameEn: string | undefined, governorate_Id: number | undefined, governorate_Name: string | undefined, governorate_CreatedByUserId: number | null | undefined, governorate_CreatedOn: Date | null | undefined, governorate_CreatedByUser_Id: number | undefined, governorate_CreatedByUser_NationalId: string | undefined, governorate_CreatedByUser_UserName: string | null | undefined, governorate_CreatedByUser_FullName: string | null | undefined, governorate_CreatedByUser_Email: string | null | undefined, governorate_CreatedByUser_PasswordHash: string | null | undefined, governorate_CreatedByUser_Photo: string | null | undefined, governorate_CreatedByUser_UserType: UserTypeEnum | null | undefined, governorate_CreatedByUser_PhoneNumber: string | null | undefined, governorate_CreatedByUser_Address: string | null | undefined, governorate_CreatedByUser_IsActive: boolean | null | undefined, governorate_UpdatedBy: number | null | undefined, governorate_UpdatedOn: Date | null | undefined, governorate_UpdatedByUser_Id: number | undefined, governorate_UpdatedByUser_NationalId: string | undefined, governorate_UpdatedByUser_UserName: string | null | undefined, governorate_UpdatedByUser_FullName: string | null | undefined, governorate_UpdatedByUser_Email: string | null | undefined, governorate_UpdatedByUser_PasswordHash: string | null | undefined, governorate_UpdatedByUser_Photo: string | null | undefined, governorate_UpdatedByUser_UserType: UserTypeEnum | null | undefined, governorate_UpdatedByUser_PhoneNumber: string | null | undefined, governorate_UpdatedByUser_Address: string | null | undefined, governorate_UpdatedByUser_IsActive: boolean | null | undefined, governorate_Cities: CityDTO[] | undefined, createdOn: Date | null | undefined, categoriesJson: string | null | undefined, categoriesDTO: CategoryDTO[] | null | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/InsertMerchant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (shopName === null || shopName === undefined)
            throw new Error("The parameter 'shopName' cannot be null.");
        else
            content_.append("ShopName", shopName.toString());
        if (slug === null || slug === undefined)
            throw new Error("The parameter 'slug' cannot be null.");
        else
            content_.append("Slug", slug.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (shortDescription === null || shortDescription === undefined)
            throw new Error("The parameter 'shortDescription' cannot be null.");
        else
            content_.append("ShortDescription", shortDescription.toString());
        if (locationOnMap === null || locationOnMap === undefined)
            throw new Error("The parameter 'locationOnMap' cannot be null.");
        else
            content_.append("LocationOnMap", locationOnMap.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (latitude !== null && latitude !== undefined)
            content_.append("Latitude", latitude.toString());
        if (longitude !== null && longitude !== undefined)
            content_.append("Longitude", longitude.toString());
        if (rating === null || rating === undefined)
            throw new Error("The parameter 'rating' cannot be null.");
        else
            content_.append("Rating", rating.toString());
        if (ratingCount === null || ratingCount === undefined)
            throw new Error("The parameter 'ratingCount' cannot be null.");
        else
            content_.append("RatingCount", ratingCount.toString());
        if (mobileNo === null || mobileNo === undefined)
            throw new Error("The parameter 'mobileNo' cannot be null.");
        else
            content_.append("MobileNo", mobileNo.toString());
        if (whatsAppMobileNo === null || whatsAppMobileNo === undefined)
            throw new Error("The parameter 'whatsAppMobileNo' cannot be null.");
        else
            content_.append("WhatsAppMobileNo", whatsAppMobileNo.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (governorateId !== null && governorateId !== undefined)
            content_.append("GovernorateId", governorateId.toString());
        if (cityId !== null && cityId !== undefined)
            content_.append("CityId", cityId.toString());
        if (isFavoriteMerchant === null || isFavoriteMerchant === undefined)
            throw new Error("The parameter 'isFavoriteMerchant' cannot be null.");
        else
            content_.append("IsFavoriteMerchant", isFavoriteMerchant.toString());
        if (commercialRegistrationNumber === null || commercialRegistrationNumber === undefined)
            throw new Error("The parameter 'commercialRegistrationNumber' cannot be null.");
        else
            content_.append("CommercialRegistrationNumber", commercialRegistrationNumber.toString());
        if (nationalIdNumber === null || nationalIdNumber === undefined)
            throw new Error("The parameter 'nationalIdNumber' cannot be null.");
        else
            content_.append("NationalIdNumber", nationalIdNumber.toString());
        if (businessHours === null || businessHours === undefined)
            throw new Error("The parameter 'businessHours' cannot be null.");
        else
            content_.append("BusinessHours", businessHours.toString());
        if (logo !== null && logo !== undefined)
            content_.append("Logo", logo.toString());
        if (commercialRegistrationImage !== null && commercialRegistrationImage !== undefined)
            content_.append("CommercialRegistrationImage", commercialRegistrationImage.toString());
        if (nationalIdImage !== null && nationalIdImage !== undefined)
            content_.append("NationalIdImage", nationalIdImage.toString());
        if (nationalIdImageForm === null || nationalIdImageForm === undefined)
            throw new Error("The parameter 'nationalIdImageForm' cannot be null.");
        else
            content_.append("NationalIdImageForm", nationalIdImageForm.data, nationalIdImageForm.fileName ? nationalIdImageForm.fileName : "NationalIdImageForm");
        if (logoForm === null || logoForm === undefined)
            throw new Error("The parameter 'logoForm' cannot be null.");
        else
            content_.append("LogoForm", logoForm.data, logoForm.fileName ? logoForm.fileName : "LogoForm");
        if (commercialRegistrationImageForm === null || commercialRegistrationImageForm === undefined)
            throw new Error("The parameter 'commercialRegistrationImageForm' cannot be null.");
        else
            content_.append("CommercialRegistrationImageForm", commercialRegistrationImageForm.data, commercialRegistrationImageForm.fileName ? commercialRegistrationImageForm.fileName : "CommercialRegistrationImageForm");
        if (membersJson !== null && membersJson !== undefined)
            content_.append("MembersJson", membersJson.toString());
        if (members !== null && members !== undefined)
            members.forEach(item_ => content_.append("Members", item_.toString()));
        if (city_Id === null || city_Id === undefined)
            throw new Error("The parameter 'city_Id' cannot be null.");
        else
            content_.append("City.Id", city_Id.toString());
        if (city_NameAr === null || city_NameAr === undefined)
            throw new Error("The parameter 'city_NameAr' cannot be null.");
        else
            content_.append("City.NameAr", city_NameAr.toString());
        if (city_NameEn === null || city_NameEn === undefined)
            throw new Error("The parameter 'city_NameEn' cannot be null.");
        else
            content_.append("City.NameEn", city_NameEn.toString());
        if (governorate_Id === null || governorate_Id === undefined)
            throw new Error("The parameter 'governorate_Id' cannot be null.");
        else
            content_.append("Governorate.Id", governorate_Id.toString());
        if (governorate_Name === null || governorate_Name === undefined)
            throw new Error("The parameter 'governorate_Name' cannot be null.");
        else
            content_.append("Governorate.Name", governorate_Name.toString());
        if (governorate_CreatedByUserId !== null && governorate_CreatedByUserId !== undefined)
            content_.append("Governorate.CreatedByUserId", governorate_CreatedByUserId.toString());
        if (governorate_CreatedOn !== null && governorate_CreatedOn !== undefined)
            content_.append("Governorate.CreatedOn", governorate_CreatedOn.toJSON());
        if (governorate_CreatedByUser_Id === null || governorate_CreatedByUser_Id === undefined)
            throw new Error("The parameter 'governorate_CreatedByUser_Id' cannot be null.");
        else
            content_.append("Governorate.CreatedByUser.Id", governorate_CreatedByUser_Id.toString());
        if (governorate_CreatedByUser_NationalId === null || governorate_CreatedByUser_NationalId === undefined)
            throw new Error("The parameter 'governorate_CreatedByUser_NationalId' cannot be null.");
        else
            content_.append("Governorate.CreatedByUser.NationalId", governorate_CreatedByUser_NationalId.toString());
        if (governorate_CreatedByUser_UserName !== null && governorate_CreatedByUser_UserName !== undefined)
            content_.append("Governorate.CreatedByUser.UserName", governorate_CreatedByUser_UserName.toString());
        if (governorate_CreatedByUser_FullName !== null && governorate_CreatedByUser_FullName !== undefined)
            content_.append("Governorate.CreatedByUser.FullName", governorate_CreatedByUser_FullName.toString());
        if (governorate_CreatedByUser_Email !== null && governorate_CreatedByUser_Email !== undefined)
            content_.append("Governorate.CreatedByUser.Email", governorate_CreatedByUser_Email.toString());
        if (governorate_CreatedByUser_PasswordHash !== null && governorate_CreatedByUser_PasswordHash !== undefined)
            content_.append("Governorate.CreatedByUser.PasswordHash", governorate_CreatedByUser_PasswordHash.toString());
        if (governorate_CreatedByUser_Photo !== null && governorate_CreatedByUser_Photo !== undefined)
            content_.append("Governorate.CreatedByUser.Photo", governorate_CreatedByUser_Photo.toString());
        if (governorate_CreatedByUser_UserType !== null && governorate_CreatedByUser_UserType !== undefined)
            content_.append("Governorate.CreatedByUser.UserType", governorate_CreatedByUser_UserType.toString());
        if (governorate_CreatedByUser_PhoneNumber !== null && governorate_CreatedByUser_PhoneNumber !== undefined)
            content_.append("Governorate.CreatedByUser.PhoneNumber", governorate_CreatedByUser_PhoneNumber.toString());
        if (governorate_CreatedByUser_Address !== null && governorate_CreatedByUser_Address !== undefined)
            content_.append("Governorate.CreatedByUser.Address", governorate_CreatedByUser_Address.toString());
        if (governorate_CreatedByUser_IsActive !== null && governorate_CreatedByUser_IsActive !== undefined)
            content_.append("Governorate.CreatedByUser.IsActive", governorate_CreatedByUser_IsActive.toString());
        if (governorate_UpdatedBy !== null && governorate_UpdatedBy !== undefined)
            content_.append("Governorate.UpdatedBy", governorate_UpdatedBy.toString());
        if (governorate_UpdatedOn !== null && governorate_UpdatedOn !== undefined)
            content_.append("Governorate.UpdatedOn", governorate_UpdatedOn.toJSON());
        if (governorate_UpdatedByUser_Id === null || governorate_UpdatedByUser_Id === undefined)
            throw new Error("The parameter 'governorate_UpdatedByUser_Id' cannot be null.");
        else
            content_.append("Governorate.UpdatedByUser.Id", governorate_UpdatedByUser_Id.toString());
        if (governorate_UpdatedByUser_NationalId === null || governorate_UpdatedByUser_NationalId === undefined)
            throw new Error("The parameter 'governorate_UpdatedByUser_NationalId' cannot be null.");
        else
            content_.append("Governorate.UpdatedByUser.NationalId", governorate_UpdatedByUser_NationalId.toString());
        if (governorate_UpdatedByUser_UserName !== null && governorate_UpdatedByUser_UserName !== undefined)
            content_.append("Governorate.UpdatedByUser.UserName", governorate_UpdatedByUser_UserName.toString());
        if (governorate_UpdatedByUser_FullName !== null && governorate_UpdatedByUser_FullName !== undefined)
            content_.append("Governorate.UpdatedByUser.FullName", governorate_UpdatedByUser_FullName.toString());
        if (governorate_UpdatedByUser_Email !== null && governorate_UpdatedByUser_Email !== undefined)
            content_.append("Governorate.UpdatedByUser.Email", governorate_UpdatedByUser_Email.toString());
        if (governorate_UpdatedByUser_PasswordHash !== null && governorate_UpdatedByUser_PasswordHash !== undefined)
            content_.append("Governorate.UpdatedByUser.PasswordHash", governorate_UpdatedByUser_PasswordHash.toString());
        if (governorate_UpdatedByUser_Photo !== null && governorate_UpdatedByUser_Photo !== undefined)
            content_.append("Governorate.UpdatedByUser.Photo", governorate_UpdatedByUser_Photo.toString());
        if (governorate_UpdatedByUser_UserType !== null && governorate_UpdatedByUser_UserType !== undefined)
            content_.append("Governorate.UpdatedByUser.UserType", governorate_UpdatedByUser_UserType.toString());
        if (governorate_UpdatedByUser_PhoneNumber !== null && governorate_UpdatedByUser_PhoneNumber !== undefined)
            content_.append("Governorate.UpdatedByUser.PhoneNumber", governorate_UpdatedByUser_PhoneNumber.toString());
        if (governorate_UpdatedByUser_Address !== null && governorate_UpdatedByUser_Address !== undefined)
            content_.append("Governorate.UpdatedByUser.Address", governorate_UpdatedByUser_Address.toString());
        if (governorate_UpdatedByUser_IsActive !== null && governorate_UpdatedByUser_IsActive !== undefined)
            content_.append("Governorate.UpdatedByUser.IsActive", governorate_UpdatedByUser_IsActive.toString());
        if (governorate_Cities === null || governorate_Cities === undefined)
            throw new Error("The parameter 'governorate_Cities' cannot be null.");
        else
            governorate_Cities.forEach(item_ => content_.append("Governorate.Cities", item_.toString()));
        if (createdOn !== null && createdOn !== undefined)
            content_.append("CreatedOn", createdOn.toJSON());
        if (categoriesJson !== null && categoriesJson !== undefined)
            content_.append("CategoriesJson", categoriesJson.toString());
        if (categoriesDTO !== null && categoriesDTO !== undefined)
            categoriesDTO.forEach(item_ => content_.append("CategoriesDTO", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantInsertMerchantPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantInsertMerchantPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantInsertMerchantPost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantPut(idPath: number, idFormData: number | undefined, shopName: string | undefined, slug: string | undefined, description: string | undefined, shortDescription: string | undefined, locationOnMap: string | undefined, address: string | undefined, latitude: number | null | undefined, longitude: number | null | undefined, rating: number | undefined, ratingCount: number | undefined, mobileNo: string | undefined, whatsAppMobileNo: string | undefined, email: string | null | undefined, governorateId: number | null | undefined, cityId: number | null | undefined, isFavoriteMerchant: boolean | undefined, commercialRegistrationNumber: string | undefined, nationalIdNumber: string | undefined, businessHours: string | undefined, logo: string | null | undefined, commercialRegistrationImage: string | null | undefined, nationalIdImage: string | null | undefined, nationalIdImageForm: FileParameter | undefined, logoForm: FileParameter | undefined, commercialRegistrationImageForm: FileParameter | undefined, membersJson: string | null | undefined, members: MemberDTO[] | null | undefined, city_Id: number | undefined, city_NameAr: string | undefined, city_NameEn: string | undefined, governorate_Id: number | undefined, governorate_Name: string | undefined, governorate_CreatedByUserId: number | null | undefined, governorate_CreatedOn: Date | null | undefined, governorate_CreatedByUser_Id: number | undefined, governorate_CreatedByUser_NationalId: string | undefined, governorate_CreatedByUser_UserName: string | null | undefined, governorate_CreatedByUser_FullName: string | null | undefined, governorate_CreatedByUser_Email: string | null | undefined, governorate_CreatedByUser_PasswordHash: string | null | undefined, governorate_CreatedByUser_Photo: string | null | undefined, governorate_CreatedByUser_UserType: UserTypeEnum | null | undefined, governorate_CreatedByUser_PhoneNumber: string | null | undefined, governorate_CreatedByUser_Address: string | null | undefined, governorate_CreatedByUser_IsActive: boolean | null | undefined, governorate_UpdatedBy: number | null | undefined, governorate_UpdatedOn: Date | null | undefined, governorate_UpdatedByUser_Id: number | undefined, governorate_UpdatedByUser_NationalId: string | undefined, governorate_UpdatedByUser_UserName: string | null | undefined, governorate_UpdatedByUser_FullName: string | null | undefined, governorate_UpdatedByUser_Email: string | null | undefined, governorate_UpdatedByUser_PasswordHash: string | null | undefined, governorate_UpdatedByUser_Photo: string | null | undefined, governorate_UpdatedByUser_UserType: UserTypeEnum | null | undefined, governorate_UpdatedByUser_PhoneNumber: string | null | undefined, governorate_UpdatedByUser_Address: string | null | undefined, governorate_UpdatedByUser_IsActive: boolean | null | undefined, governorate_Cities: CityDTO[] | undefined, createdOn: Date | null | undefined, categoriesJson: string | null | undefined, categoriesDTO: CategoryDTO[] | null | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/{id}";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (shopName === null || shopName === undefined)
            throw new Error("The parameter 'shopName' cannot be null.");
        else
            content_.append("ShopName", shopName.toString());
        if (slug === null || slug === undefined)
            throw new Error("The parameter 'slug' cannot be null.");
        else
            content_.append("Slug", slug.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (shortDescription === null || shortDescription === undefined)
            throw new Error("The parameter 'shortDescription' cannot be null.");
        else
            content_.append("ShortDescription", shortDescription.toString());
        if (locationOnMap === null || locationOnMap === undefined)
            throw new Error("The parameter 'locationOnMap' cannot be null.");
        else
            content_.append("LocationOnMap", locationOnMap.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (latitude !== null && latitude !== undefined)
            content_.append("Latitude", latitude.toString());
        if (longitude !== null && longitude !== undefined)
            content_.append("Longitude", longitude.toString());
        if (rating === null || rating === undefined)
            throw new Error("The parameter 'rating' cannot be null.");
        else
            content_.append("Rating", rating.toString());
        if (ratingCount === null || ratingCount === undefined)
            throw new Error("The parameter 'ratingCount' cannot be null.");
        else
            content_.append("RatingCount", ratingCount.toString());
        if (mobileNo === null || mobileNo === undefined)
            throw new Error("The parameter 'mobileNo' cannot be null.");
        else
            content_.append("MobileNo", mobileNo.toString());
        if (whatsAppMobileNo === null || whatsAppMobileNo === undefined)
            throw new Error("The parameter 'whatsAppMobileNo' cannot be null.");
        else
            content_.append("WhatsAppMobileNo", whatsAppMobileNo.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (governorateId !== null && governorateId !== undefined)
            content_.append("GovernorateId", governorateId.toString());
        if (cityId !== null && cityId !== undefined)
            content_.append("CityId", cityId.toString());
        if (isFavoriteMerchant === null || isFavoriteMerchant === undefined)
            throw new Error("The parameter 'isFavoriteMerchant' cannot be null.");
        else
            content_.append("IsFavoriteMerchant", isFavoriteMerchant.toString());
        if (commercialRegistrationNumber === null || commercialRegistrationNumber === undefined)
            throw new Error("The parameter 'commercialRegistrationNumber' cannot be null.");
        else
            content_.append("CommercialRegistrationNumber", commercialRegistrationNumber.toString());
        if (nationalIdNumber === null || nationalIdNumber === undefined)
            throw new Error("The parameter 'nationalIdNumber' cannot be null.");
        else
            content_.append("NationalIdNumber", nationalIdNumber.toString());
        if (businessHours === null || businessHours === undefined)
            throw new Error("The parameter 'businessHours' cannot be null.");
        else
            content_.append("BusinessHours", businessHours.toString());
        if (logo !== null && logo !== undefined)
            content_.append("Logo", logo.toString());
        if (commercialRegistrationImage !== null && commercialRegistrationImage !== undefined)
            content_.append("CommercialRegistrationImage", commercialRegistrationImage.toString());
        if (nationalIdImage !== null && nationalIdImage !== undefined)
            content_.append("NationalIdImage", nationalIdImage.toString());
        if (nationalIdImageForm === null || nationalIdImageForm === undefined)
            throw new Error("The parameter 'nationalIdImageForm' cannot be null.");
        else
            content_.append("NationalIdImageForm", nationalIdImageForm.data, nationalIdImageForm.fileName ? nationalIdImageForm.fileName : "NationalIdImageForm");
        if (logoForm === null || logoForm === undefined)
            throw new Error("The parameter 'logoForm' cannot be null.");
        else
            content_.append("LogoForm", logoForm.data, logoForm.fileName ? logoForm.fileName : "LogoForm");
        if (commercialRegistrationImageForm === null || commercialRegistrationImageForm === undefined)
            throw new Error("The parameter 'commercialRegistrationImageForm' cannot be null.");
        else
            content_.append("CommercialRegistrationImageForm", commercialRegistrationImageForm.data, commercialRegistrationImageForm.fileName ? commercialRegistrationImageForm.fileName : "CommercialRegistrationImageForm");
        if (membersJson !== null && membersJson !== undefined)
            content_.append("MembersJson", membersJson.toString());
        if (members !== null && members !== undefined)
            members.forEach(item_ => content_.append("Members", item_.toString()));
        if (city_Id === null || city_Id === undefined)
            throw new Error("The parameter 'city_Id' cannot be null.");
        else
            content_.append("City.Id", city_Id.toString());
        if (city_NameAr === null || city_NameAr === undefined)
            throw new Error("The parameter 'city_NameAr' cannot be null.");
        else
            content_.append("City.NameAr", city_NameAr.toString());
        if (city_NameEn === null || city_NameEn === undefined)
            throw new Error("The parameter 'city_NameEn' cannot be null.");
        else
            content_.append("City.NameEn", city_NameEn.toString());
        if (governorate_Id === null || governorate_Id === undefined)
            throw new Error("The parameter 'governorate_Id' cannot be null.");
        else
            content_.append("Governorate.Id", governorate_Id.toString());
        if (governorate_Name === null || governorate_Name === undefined)
            throw new Error("The parameter 'governorate_Name' cannot be null.");
        else
            content_.append("Governorate.Name", governorate_Name.toString());
        if (governorate_CreatedByUserId !== null && governorate_CreatedByUserId !== undefined)
            content_.append("Governorate.CreatedByUserId", governorate_CreatedByUserId.toString());
        if (governorate_CreatedOn !== null && governorate_CreatedOn !== undefined)
            content_.append("Governorate.CreatedOn", governorate_CreatedOn.toJSON());
        if (governorate_CreatedByUser_Id === null || governorate_CreatedByUser_Id === undefined)
            throw new Error("The parameter 'governorate_CreatedByUser_Id' cannot be null.");
        else
            content_.append("Governorate.CreatedByUser.Id", governorate_CreatedByUser_Id.toString());
        if (governorate_CreatedByUser_NationalId === null || governorate_CreatedByUser_NationalId === undefined)
            throw new Error("The parameter 'governorate_CreatedByUser_NationalId' cannot be null.");
        else
            content_.append("Governorate.CreatedByUser.NationalId", governorate_CreatedByUser_NationalId.toString());
        if (governorate_CreatedByUser_UserName !== null && governorate_CreatedByUser_UserName !== undefined)
            content_.append("Governorate.CreatedByUser.UserName", governorate_CreatedByUser_UserName.toString());
        if (governorate_CreatedByUser_FullName !== null && governorate_CreatedByUser_FullName !== undefined)
            content_.append("Governorate.CreatedByUser.FullName", governorate_CreatedByUser_FullName.toString());
        if (governorate_CreatedByUser_Email !== null && governorate_CreatedByUser_Email !== undefined)
            content_.append("Governorate.CreatedByUser.Email", governorate_CreatedByUser_Email.toString());
        if (governorate_CreatedByUser_PasswordHash !== null && governorate_CreatedByUser_PasswordHash !== undefined)
            content_.append("Governorate.CreatedByUser.PasswordHash", governorate_CreatedByUser_PasswordHash.toString());
        if (governorate_CreatedByUser_Photo !== null && governorate_CreatedByUser_Photo !== undefined)
            content_.append("Governorate.CreatedByUser.Photo", governorate_CreatedByUser_Photo.toString());
        if (governorate_CreatedByUser_UserType !== null && governorate_CreatedByUser_UserType !== undefined)
            content_.append("Governorate.CreatedByUser.UserType", governorate_CreatedByUser_UserType.toString());
        if (governorate_CreatedByUser_PhoneNumber !== null && governorate_CreatedByUser_PhoneNumber !== undefined)
            content_.append("Governorate.CreatedByUser.PhoneNumber", governorate_CreatedByUser_PhoneNumber.toString());
        if (governorate_CreatedByUser_Address !== null && governorate_CreatedByUser_Address !== undefined)
            content_.append("Governorate.CreatedByUser.Address", governorate_CreatedByUser_Address.toString());
        if (governorate_CreatedByUser_IsActive !== null && governorate_CreatedByUser_IsActive !== undefined)
            content_.append("Governorate.CreatedByUser.IsActive", governorate_CreatedByUser_IsActive.toString());
        if (governorate_UpdatedBy !== null && governorate_UpdatedBy !== undefined)
            content_.append("Governorate.UpdatedBy", governorate_UpdatedBy.toString());
        if (governorate_UpdatedOn !== null && governorate_UpdatedOn !== undefined)
            content_.append("Governorate.UpdatedOn", governorate_UpdatedOn.toJSON());
        if (governorate_UpdatedByUser_Id === null || governorate_UpdatedByUser_Id === undefined)
            throw new Error("The parameter 'governorate_UpdatedByUser_Id' cannot be null.");
        else
            content_.append("Governorate.UpdatedByUser.Id", governorate_UpdatedByUser_Id.toString());
        if (governorate_UpdatedByUser_NationalId === null || governorate_UpdatedByUser_NationalId === undefined)
            throw new Error("The parameter 'governorate_UpdatedByUser_NationalId' cannot be null.");
        else
            content_.append("Governorate.UpdatedByUser.NationalId", governorate_UpdatedByUser_NationalId.toString());
        if (governorate_UpdatedByUser_UserName !== null && governorate_UpdatedByUser_UserName !== undefined)
            content_.append("Governorate.UpdatedByUser.UserName", governorate_UpdatedByUser_UserName.toString());
        if (governorate_UpdatedByUser_FullName !== null && governorate_UpdatedByUser_FullName !== undefined)
            content_.append("Governorate.UpdatedByUser.FullName", governorate_UpdatedByUser_FullName.toString());
        if (governorate_UpdatedByUser_Email !== null && governorate_UpdatedByUser_Email !== undefined)
            content_.append("Governorate.UpdatedByUser.Email", governorate_UpdatedByUser_Email.toString());
        if (governorate_UpdatedByUser_PasswordHash !== null && governorate_UpdatedByUser_PasswordHash !== undefined)
            content_.append("Governorate.UpdatedByUser.PasswordHash", governorate_UpdatedByUser_PasswordHash.toString());
        if (governorate_UpdatedByUser_Photo !== null && governorate_UpdatedByUser_Photo !== undefined)
            content_.append("Governorate.UpdatedByUser.Photo", governorate_UpdatedByUser_Photo.toString());
        if (governorate_UpdatedByUser_UserType !== null && governorate_UpdatedByUser_UserType !== undefined)
            content_.append("Governorate.UpdatedByUser.UserType", governorate_UpdatedByUser_UserType.toString());
        if (governorate_UpdatedByUser_PhoneNumber !== null && governorate_UpdatedByUser_PhoneNumber !== undefined)
            content_.append("Governorate.UpdatedByUser.PhoneNumber", governorate_UpdatedByUser_PhoneNumber.toString());
        if (governorate_UpdatedByUser_Address !== null && governorate_UpdatedByUser_Address !== undefined)
            content_.append("Governorate.UpdatedByUser.Address", governorate_UpdatedByUser_Address.toString());
        if (governorate_UpdatedByUser_IsActive !== null && governorate_UpdatedByUser_IsActive !== undefined)
            content_.append("Governorate.UpdatedByUser.IsActive", governorate_UpdatedByUser_IsActive.toString());
        if (governorate_Cities === null || governorate_Cities === undefined)
            throw new Error("The parameter 'governorate_Cities' cannot be null.");
        else
            governorate_Cities.forEach(item_ => content_.append("Governorate.Cities", item_.toString()));
        if (createdOn !== null && createdOn !== undefined)
            content_.append("CreatedOn", createdOn.toJSON());
        if (categoriesJson !== null && categoriesJson !== undefined)
            content_.append("CategoriesJson", categoriesJson.toString());
        if (categoriesDTO !== null && categoriesDTO !== undefined)
            categoriesDTO.forEach(item_ => content_.append("CategoriesDTO", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantPut(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfMerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfMerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfMerchantDTO>;
        }));
    }

    protected processApiMerchantGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfMerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfMerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantGetDetailsGet(id: number | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantGetDetailsGet(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantInsertPost(entity: MerchantDTO): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantInsertPost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantUpdatePost(entity: MerchantDTO): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantUpdatePost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMerchantDeletePost(id: number | undefined): Observable<MerchantDTO> {
        let url_ = this.baseUrl + "/api/Merchant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMerchantDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMerchantDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantDTO>;
        }));
    }

    protected processApiMerchantDeletePost(response: HttpResponseBase): Observable<MerchantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfPartDTO> {
        let url_ = this.baseUrl + "/api/Parts/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfPartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfPartDTO>;
        }));
    }

    protected processApiPartsGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfPartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfPartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsGetDetailsGet(id: number | undefined): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsGetDetailsGet(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsInsertPost(entity: PartDTO): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsInsertPost(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsUpdatePost(entity: PartDTO): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsUpdatePost(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiPartsDeletePost(id: number | undefined): Observable<PartDTO> {
        let url_ = this.baseUrl + "/api/Parts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPartsDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPartsDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartDTO>;
        }));
    }

    protected processApiPartsDeletePost(response: HttpResponseBase): Observable<PartDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PartDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountLoginPost(loginViewModel: LoginViewModel): Observable<AuthDto> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountLoginPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountLoginPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthDto>;
        }));
    }

    protected processApiAccountLoginPost(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountRegisterNewUserPost(registerViewModel: RegisterViewModel): Observable<AuthDto> {
        let url_ = this.baseUrl + "/api/Account/RegisterNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountRegisterNewUserPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountRegisterNewUserPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthDto>;
        }));
    }

    protected processApiAccountRegisterNewUserPost(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountRegisterNewVisitorPost(visitorViewModel: VisitorViewModel): Observable<AuthDto> {
        let url_ = this.baseUrl + "/api/Account/RegisterNewVisitor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(visitorViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountRegisterNewVisitorPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountRegisterNewVisitorPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthDto>;
        }));
    }

    protected processApiAccountRegisterNewVisitorPost(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfUserDTO> {
        let url_ = this.baseUrl + "/api/Account/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfUserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfUserDTO>;
        }));
    }

    protected processApiAccountGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfUserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfUserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountGetDetailsGet(id: number | undefined): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountGetDetailsGet(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountInsertPost(entity: UserDTO): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountInsertPost(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountUpdatePost(entity: UserDTO): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountUpdatePost(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiAccountDeletePost(id: number | undefined): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Account/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTO>;
        }));
    }

    protected processApiAccountDeletePost(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfCarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfCarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfCarsModelDto>;
        }));
    }

    protected processApiCarsModelGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfCarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfCarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelGetDetailsGet(id: number | undefined): Observable<CarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarsModelDto>;
        }));
    }

    protected processApiCarsModelGetDetailsGet(response: HttpResponseBase): Observable<CarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelInsertPost(entity: CarsModelDto): Observable<CarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarsModelDto>;
        }));
    }

    protected processApiCarsModelInsertPost(response: HttpResponseBase): Observable<CarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelUpdatePost(entity: CarsModelDto): Observable<CarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarsModelDto>;
        }));
    }

    protected processApiCarsModelUpdatePost(response: HttpResponseBase): Observable<CarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCarsModelDeletePost(id: number | undefined): Observable<CarsModelDto> {
        let url_ = this.baseUrl + "/api/CarsModel/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCarsModelDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCarsModelDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarsModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarsModelDto>;
        }));
    }

    protected processApiCarsModelDeletePost(response: HttpResponseBase): Observable<CarsModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarsModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCategoryAllGet(): Observable<CategoryDTO[]> {
        let url_ = this.baseUrl + "/api/Category/All";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCategoryAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCategoryAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDTO[]>;
        }));
    }

    protected processApiCategoryAllGet(response: HttpResponseBase): Observable<CategoryDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityGetAllGet(pageSize: number | undefined, page: number | undefined, searchTerm: string | null | undefined): Observable<DataSourceResultOfCityDTO> {
        let url_ = this.baseUrl + "/api/City/GetAll?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataSourceResultOfCityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataSourceResultOfCityDTO>;
        }));
    }

    protected processApiCityGetAllGet(response: HttpResponseBase): Observable<DataSourceResultOfCityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceResultOfCityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityGetDetailsGet(id: number | undefined): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/GetDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityGetDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityGetDetailsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityGetDetailsGet(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityInsertPost(entity: CityDTO): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityInsertPost(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityUpdatePost(entity: CityDTO): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityUpdatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityUpdatePost(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCityDeletePost(id: number | undefined): Observable<CityDTO> {
        let url_ = this.baseUrl + "/api/City/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCityDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCityDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTO>;
        }));
    }

    protected processApiCityDeletePost(response: HttpResponseBase): Observable<CityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetLookupGet(lookupName: string | undefined, searchTerm: string | null | undefined): Observable<LookupDTO[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetLookup?";
        if (lookupName === null)
            throw new Error("The parameter 'lookupName' cannot be null.");
        else if (lookupName !== undefined)
            url_ += "lookupName=" + encodeURIComponent("" + lookupName) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetLookupGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetLookupGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupDTO[]>;
        }));
    }

    protected processApiLookupGetLookupGet(response: HttpResponseBase): Observable<LookupDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGovernoratesGet(): Observable<GovernorateLookupDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Governorates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGovernoratesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGovernoratesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateLookupDto[]>;
        }));
    }

    protected processApiLookupGovernoratesGet(response: HttpResponseBase): Observable<GovernorateLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GovernorateLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupCitiesGet(governorateId: number | null | undefined): Observable<CityLookupDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Cities?";
        if (governorateId !== undefined && governorateId !== null)
            url_ += "governorateId=" + encodeURIComponent("" + governorateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupCitiesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupCitiesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityLookupDto[]>;
        }));
    }

    protected processApiLookupCitiesGet(response: HttpResponseBase): Observable<CityLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class DataSourceResultOfCategoryDTO implements IDataSourceResultOfCategoryDTO {
    data!: CategoryDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfCategoryDTO {
    data: CategoryDTO[];
    count: number;
    additionalValue: number;
}

export class CategoryDTO implements ICategoryDTO {
    id!: number;
    name!: string;

    constructor(data?: ICategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICategoryDTO {
    id: number;
    name: string;
}

export class MerchantDTO implements IMerchantDTO {
    id!: number;
    shopName!: string;
    slug!: string;
    description!: string;
    shortDescription!: string;
    locationOnMap!: string;
    address!: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    rating!: number;
    ratingCount!: number;
    mobileNo!: string;
    whatsAppMobileNo!: string;
    email?: string | undefined;
    governorateId?: number | undefined;
    cityId?: number | undefined;
    isFavoriteMerchant!: boolean;
    commercialRegistrationNumber!: string;
    nationalIdNumber!: string;
    businessHours!: string;
    logo?: string | undefined;
    commercialRegistrationImage?: string | undefined;
    nationalIdImage?: string | undefined;
    nationalIdImageForm!: any;
    logoForm!: any;
    commercialRegistrationImageForm!: any;
    membersJson?: string | undefined;
    members?: MemberDTO[] | undefined;
    city?: CityDTO | undefined;
    governorate?: GovernorateDTO | undefined;
    createdOn?: Date | undefined;
    categoriesJson?: string | undefined;
    categoriesDTO?: CategoryDTO[] | undefined;

    constructor(data?: IMerchantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shopName = _data["shopName"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.locationOnMap = _data["locationOnMap"];
            this.address = _data["address"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.rating = _data["rating"];
            this.ratingCount = _data["ratingCount"];
            this.mobileNo = _data["mobileNo"];
            this.whatsAppMobileNo = _data["whatsAppMobileNo"];
            this.email = _data["email"];
            this.governorateId = _data["governorateId"];
            this.cityId = _data["cityId"];
            this.isFavoriteMerchant = _data["isFavoriteMerchant"];
            this.commercialRegistrationNumber = _data["commercialRegistrationNumber"];
            this.nationalIdNumber = _data["nationalIdNumber"];
            this.businessHours = _data["businessHours"];
            this.logo = _data["logo"];
            this.commercialRegistrationImage = _data["commercialRegistrationImage"];
            this.nationalIdImage = _data["nationalIdImage"];
            this.nationalIdImageForm = _data["nationalIdImageForm"];
            this.logoForm = _data["logoForm"];
            this.commercialRegistrationImageForm = _data["commercialRegistrationImageForm"];
            this.membersJson = _data["membersJson"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(MemberDTO.fromJS(item));
            }
            this.city = _data["city"] ? CityDTO.fromJS(_data["city"]) : <any>undefined;
            this.governorate = _data["governorate"] ? GovernorateDTO.fromJS(_data["governorate"]) : <any>undefined;
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.categoriesJson = _data["categoriesJson"];
            if (Array.isArray(_data["categoriesDTO"])) {
                this.categoriesDTO = [] as any;
                for (let item of _data["categoriesDTO"])
                    this.categoriesDTO!.push(CategoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MerchantDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shopName"] = this.shopName;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["locationOnMap"] = this.locationOnMap;
        data["address"] = this.address;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["rating"] = this.rating;
        data["ratingCount"] = this.ratingCount;
        data["mobileNo"] = this.mobileNo;
        data["whatsAppMobileNo"] = this.whatsAppMobileNo;
        data["email"] = this.email;
        data["governorateId"] = this.governorateId;
        data["cityId"] = this.cityId;
        data["isFavoriteMerchant"] = this.isFavoriteMerchant;
        data["commercialRegistrationNumber"] = this.commercialRegistrationNumber;
        data["nationalIdNumber"] = this.nationalIdNumber;
        data["businessHours"] = this.businessHours;
        data["logo"] = this.logo;
        data["commercialRegistrationImage"] = this.commercialRegistrationImage;
        data["nationalIdImage"] = this.nationalIdImage;
        data["nationalIdImageForm"] = this.nationalIdImageForm;
        data["logoForm"] = this.logoForm;
        data["commercialRegistrationImageForm"] = this.commercialRegistrationImageForm;
        data["membersJson"] = this.membersJson;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item.toJSON());
        }
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["governorate"] = this.governorate ? this.governorate.toJSON() : <any>undefined;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["categoriesJson"] = this.categoriesJson;
        if (Array.isArray(this.categoriesDTO)) {
            data["categoriesDTO"] = [];
            for (let item of this.categoriesDTO)
                data["categoriesDTO"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMerchantDTO {
    id: number;
    shopName: string;
    slug: string;
    description: string;
    shortDescription: string;
    locationOnMap: string;
    address: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    rating: number;
    ratingCount: number;
    mobileNo: string;
    whatsAppMobileNo: string;
    email?: string | undefined;
    governorateId?: number | undefined;
    cityId?: number | undefined;
    isFavoriteMerchant: boolean;
    commercialRegistrationNumber: string;
    nationalIdNumber: string;
    businessHours: string;
    logo?: string | undefined;
    commercialRegistrationImage?: string | undefined;
    nationalIdImage?: string | undefined;
    nationalIdImageForm: any;
    logoForm: any;
    commercialRegistrationImageForm: any;
    membersJson?: string | undefined;
    members?: MemberDTO[] | undefined;
    city?: CityDTO | undefined;
    governorate?: GovernorateDTO | undefined;
    createdOn?: Date | undefined;
    categoriesJson?: string | undefined;
    categoriesDTO?: CategoryDTO[] | undefined;
}

export class MemberDTO implements IMemberDTO {
    id!: number;
    userId!: number;
    merchantId!: number;
    role!: string;
    userDTO!: UserDTO;

    constructor(data?: IMemberDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userDTO = new UserDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.merchantId = _data["merchantId"];
            this.role = _data["role"];
            this.userDTO = _data["userDTO"] ? UserDTO.fromJS(_data["userDTO"]) : new UserDTO();
        }
    }

    static fromJS(data: any): MemberDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["merchantId"] = this.merchantId;
        data["role"] = this.role;
        data["userDTO"] = this.userDTO ? this.userDTO.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMemberDTO {
    id: number;
    userId: number;
    merchantId: number;
    role: string;
    userDTO: UserDTO;
}

export class UserDTO implements IUserDTO {
    id!: number;
    nationalId!: string;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    passwordHash?: string | undefined;
    photo?: string | undefined;
    userType?: UserTypeEnum | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nationalId = _data["nationalId"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.passwordHash = _data["passwordHash"];
            this.photo = _data["photo"];
            this.userType = _data["userType"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nationalId"] = this.nationalId;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["passwordHash"] = this.passwordHash;
        data["photo"] = this.photo;
        data["userType"] = this.userType;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUserDTO {
    id: number;
    nationalId: string;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    passwordHash?: string | undefined;
    photo?: string | undefined;
    userType?: UserTypeEnum | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    isActive?: boolean | undefined;
}

export enum UserTypeEnum {
    Admin = 1,
    Client = 2,
    Seller = 3,
    ShippingCompany = 4,
}

export class CityDTO implements ICityDTO {
    id!: number;
    nameAr!: string;
    nameEn!: string;

    constructor(data?: ICityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
        }
    }

    static fromJS(data: any): CityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        return data;
    }
}

export interface ICityDTO {
    id: number;
    nameAr: string;
    nameEn: string;
}

export class GovernorateDTO implements IGovernorateDTO {
    id!: number;
    name!: string;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;
    createdByUser!: UserDTO;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    updatedByUser!: UserDTO;
    cities!: CityDTO[];

    constructor(data?: IGovernorateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdByUser = new UserDTO();
            this.updatedByUser = new UserDTO();
            this.cities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.createdByUserId = _data["createdByUserId"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.createdByUser = _data["createdByUser"] ? UserDTO.fromJS(_data["createdByUser"]) : new UserDTO();
            this.updatedBy = _data["updatedBy"];
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            this.updatedByUser = _data["updatedByUser"] ? UserDTO.fromJS(_data["updatedByUser"]) : new UserDTO();
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities!.push(CityDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GovernorateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GovernorateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["createdByUserId"] = this.createdByUserId;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : <any>undefined;
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGovernorateDTO {
    id: number;
    name: string;
    createdByUserId?: number | undefined;
    createdOn?: Date | undefined;
    createdByUser: UserDTO;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    updatedByUser: UserDTO;
    cities: CityDTO[];
}

export class DataSourceResultOfMerchantDTO implements IDataSourceResultOfMerchantDTO {
    data!: MerchantDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfMerchantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MerchantDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfMerchantDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfMerchantDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfMerchantDTO {
    data: MerchantDTO[];
    count: number;
    additionalValue: number;
}

export class DataSourceResultOfPartDTO implements IDataSourceResultOfPartDTO {
    data!: PartDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfPartDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PartDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfPartDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfPartDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfPartDTO {
    data: PartDTO[];
    count: number;
    additionalValue: number;
}

export class PartDTO implements IPartDTO {
    id!: number;
    name!: string;
    description!: string;
    price!: number;
    condition!: PartConditionEnum;
    conditionName!: string;
    imageUrl!: string;
    sellerId!: number;
    sellerName!: string;
    categoryId!: number;
    categoryName!: string;
    carModelId?: number | undefined;
    carModelName?: string | undefined;

    constructor(data?: IPartDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.condition = _data["condition"];
            this.conditionName = _data["conditionName"];
            this.imageUrl = _data["imageUrl"];
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.carModelId = _data["carModelId"];
            this.carModelName = _data["carModelName"];
        }
    }

    static fromJS(data: any): PartDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PartDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["condition"] = this.condition;
        data["conditionName"] = this.conditionName;
        data["imageUrl"] = this.imageUrl;
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["carModelId"] = this.carModelId;
        data["carModelName"] = this.carModelName;
        return data;
    }
}

export interface IPartDTO {
    id: number;
    name: string;
    description: string;
    price: number;
    condition: PartConditionEnum;
    conditionName: string;
    imageUrl: string;
    sellerId: number;
    sellerName: string;
    categoryId: number;
    categoryName: string;
    carModelId?: number | undefined;
    carModelName?: string | undefined;
}

export enum PartConditionEnum {
    New = 1,
    Used = 2,
    Refurbished = 3,
}

export class AuthDto implements IAuthDto {
    userId!: number;
    userName!: string;
    fullName!: string;
    phoneNumber?: string | undefined;
    photo?: string | undefined;
    token!: string;
    message!: string;
    statusCode?: number | undefined;
    isAuthenticated!: boolean;
    isAdmin!: boolean;
    userType!: UserTypeEnum;

    constructor(data?: IAuthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.photo = _data["photo"];
            this.token = _data["token"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.isAdmin = _data["isAdmin"];
            this.userType = _data["userType"];
        }
    }

    static fromJS(data: any): AuthDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["photo"] = this.photo;
        data["token"] = this.token;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["isAuthenticated"] = this.isAuthenticated;
        data["isAdmin"] = this.isAdmin;
        data["userType"] = this.userType;
        return data;
    }
}

export interface IAuthDto {
    userId: number;
    userName: string;
    fullName: string;
    phoneNumber?: string | undefined;
    photo?: string | undefined;
    token: string;
    message: string;
    statusCode?: number | undefined;
    isAuthenticated: boolean;
    isAdmin: boolean;
    userType: UserTypeEnum;
}

export class LoginViewModel implements ILoginViewModel {
    email!: string;
    password!: string;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginViewModel {
    email: string;
    password: string;
}

export class RegisterViewModel implements IRegisterViewModel {
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    photo?: string | undefined;
    address?: string | undefined;
    userType!: UserTypeEnum;

    constructor(data?: IRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.photo = _data["photo"];
            this.address = _data["address"];
            this.userType = _data["userType"];
        }
    }

    static fromJS(data: any): RegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["photo"] = this.photo;
        data["address"] = this.address;
        data["userType"] = this.userType;
        return data;
    }
}

export interface IRegisterViewModel {
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    photo?: string | undefined;
    address?: string | undefined;
    userType: UserTypeEnum;
}

export class VisitorViewModel implements IVisitorViewModel {
    userName!: string;
    fullName!: string;
    email!: string;
    phoneNumber!: string;
    address!: string;

    constructor(data?: IVisitorViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): VisitorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new VisitorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        return data;
    }
}

export interface IVisitorViewModel {
    userName: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    address: string;
}

export class DataSourceResultOfUserDTO implements IDataSourceResultOfUserDTO {
    data!: UserDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfUserDTO {
    data: UserDTO[];
    count: number;
    additionalValue: number;
}

export class DataSourceResultOfCarsModelDto implements IDataSourceResultOfCarsModelDto {
    data!: CarsModelDto[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfCarsModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CarsModelDto.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCarsModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCarsModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfCarsModelDto {
    data: CarsModelDto[];
    count: number;
    additionalValue: number;
}

export class CarsModelDto implements ICarsModelDto {
    id!: number;
    name!: string;

    constructor(data?: ICarsModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CarsModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarsModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICarsModelDto {
    id: number;
    name: string;
}

export class DataSourceResultOfCityDTO implements IDataSourceResultOfCityDTO {
    data!: CityDTO[];
    count!: number;
    additionalValue!: number;

    constructor(data?: IDataSourceResultOfCityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CityDTO.fromJS(item));
            }
            this.count = _data["count"];
            this.additionalValue = _data["additionalValue"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["additionalValue"] = this.additionalValue;
        return data;
    }
}

export interface IDataSourceResultOfCityDTO {
    data: CityDTO[];
    count: number;
    additionalValue: number;
}

export class LookupDTO implements ILookupDTO {
    id!: any;
    text!: string;

    constructor(data?: ILookupDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): LookupDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data;
    }
}

export interface ILookupDTO {
    id: any;
    text: string;
}

export class GovernorateLookupDto implements IGovernorateLookupDto {
    id!: number;
    name!: string;

    constructor(data?: IGovernorateLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GovernorateLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GovernorateLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGovernorateLookupDto {
    id: number;
    name: string;
}

export class CityLookupDto implements ICityLookupDto {
    id!: number;
    nameAr!: string;
    governorateId!: number;

    constructor(data?: ICityLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameAr = _data["nameAr"];
            this.governorateId = _data["governorateId"];
        }
    }

    static fromJS(data: any): CityLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameAr"] = this.nameAr;
        data["governorateId"] = this.governorateId;
        return data;
    }
}

export interface ICityLookupDto {
    id: number;
    nameAr: string;
    governorateId: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}